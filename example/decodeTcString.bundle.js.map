{"version":3,"file":"decodeTcString.bundle.js","sources":["../node_modules/@iabtcf/core/lib/mjs/errors/DecodingError.js","../node_modules/@iabtcf/core/lib/mjs/errors/EncodingError.js","../node_modules/@iabtcf/core/lib/mjs/errors/GVLError.js","../node_modules/@iabtcf/core/lib/mjs/errors/TCModelError.js","../node_modules/@iabtcf/core/lib/mjs/encoder/Base64Url.js","../node_modules/@iabtcf/core/lib/mjs/Cloneable.js","../node_modules/@iabtcf/core/lib/mjs/model/BinarySearchTree.js","../node_modules/@iabtcf/core/lib/mjs/model/ConsentLanguages.js","../node_modules/@iabtcf/core/lib/mjs/model/Fields.js","../node_modules/@iabtcf/core/lib/mjs/model/RestrictionType.js","../node_modules/@iabtcf/core/lib/mjs/model/DeviceDisclosureStorageAccessType.js","../node_modules/@iabtcf/core/lib/mjs/model/Segment.js","../node_modules/@iabtcf/core/lib/mjs/encoder/field/VectorEncodingType.js","../node_modules/@iabtcf/core/lib/mjs/model/PurposeRestriction.js","../node_modules/@iabtcf/core/lib/mjs/model/PurposeRestrictionVector.js","../node_modules/@iabtcf/core/lib/mjs/model/SegmentIDs.js","../node_modules/@iabtcf/core/lib/mjs/model/Vector.js","../node_modules/@iabtcf/core/lib/mjs/encoder/BitLength.js","../node_modules/@iabtcf/core/lib/mjs/encoder/field/BooleanEncoder.js","../node_modules/@iabtcf/core/lib/mjs/encoder/field/IntEncoder.js","../node_modules/@iabtcf/core/lib/mjs/encoder/field/DateEncoder.js","../node_modules/@iabtcf/core/lib/mjs/encoder/field/FixedVectorEncoder.js","../node_modules/@iabtcf/core/lib/mjs/encoder/field/LangEncoder.js","../node_modules/@iabtcf/core/lib/mjs/encoder/field/PurposeRestrictionVectorEncoder.js","../node_modules/@iabtcf/core/lib/mjs/encoder/field/VendorVectorEncoder.js","../node_modules/@iabtcf/core/lib/mjs/encoder/field/FieldEncoderMap.js","../node_modules/@iabtcf/core/lib/mjs/encoder/sequence/FieldSequence.js","../node_modules/@iabtcf/core/lib/mjs/encoder/sequence/SegmentSequence.js","../node_modules/@iabtcf/core/lib/mjs/encoder/SegmentEncoder.js","../node_modules/@iabtcf/core/lib/mjs/encoder/SemanticPreEncoder.js","../node_modules/@iabtcf/core/lib/mjs/Json.js","../node_modules/@iabtcf/core/lib/mjs/GVL.js","../node_modules/@iabtcf/core/lib/mjs/TCModel.js","../node_modules/@iabtcf/core/lib/mjs/TCString.js","../src/index.js"],"sourcesContent":["/**\n * class for decoding errors\n *\n * @extends {Error}\n */\nclass DecodingError extends Error {\n    /**\n     * constructor - constructs an DecodingError\n     *\n     * @param {string} msg - Decoding Error Message\n     * @return {undefined}\n     */\n    constructor(msg) {\n        super(msg);\n        this.name = 'DecodingError';\n    }\n}\nexport { DecodingError };\n","/**\n * class for encoding errors\n *\n * @extends {Error}\n */\nclass EncodingError extends Error {\n    /**\n     * constructor - constructs an EncodingError\n     *\n     * @param {string} msg - Encoding Error Message\n     * @return {undefined}\n     */\n    constructor(msg) {\n        super(msg);\n        this.name = 'EncodingError';\n    }\n}\nexport { EncodingError };\n","/**\n * class for General GVL Errors\n *\n * @extends {Error}\n */\nclass GVLError extends Error {\n    /**\n     * constructor - constructs a GVLError\n     *\n     * @param {string} msg - Error message to display\n     * @return {undefined}\n     */\n    constructor(msg) {\n        super(msg);\n        this.name = 'GVLError';\n    }\n}\nexport { GVLError };\n","/**\n * class for decoding errors\n *\n * @extends {Error}\n */\nclass TCModelError extends Error {\n    /**\n     * constructor - constructs an TCModelError\n     *\n     * @param {string} fieldName - the errored field\n     * @param {string} passedValue - what was passed\n     * @return {undefined}\n     */\n    constructor(fieldName, passedValue, msg = '') {\n        super(`invalid value ${passedValue} passed for ${fieldName} ${msg}`);\n        this.name = 'TCModelError';\n    }\n}\nexport { TCModelError };\n","import { DecodingError, EncodingError } from '../errors/index.js';\nexport class Base64Url {\n    /**\n     * Base 64 URL character set.  Different from standard Base64 char set\n     * in that '+' and '/' are replaced with '-' and '_'.\n     */\n    static DICT = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n    static REVERSE_DICT = new Map([\n        ['A', 0], ['B', 1], ['C', 2], ['D', 3], ['E', 4], ['F', 5],\n        ['G', 6], ['H', 7], ['I', 8], ['J', 9], ['K', 10], ['L', 11],\n        ['M', 12], ['N', 13], ['O', 14], ['P', 15], ['Q', 16], ['R', 17],\n        ['S', 18], ['T', 19], ['U', 20], ['V', 21], ['W', 22], ['X', 23],\n        ['Y', 24], ['Z', 25], ['a', 26], ['b', 27], ['c', 28], ['d', 29],\n        ['e', 30], ['f', 31], ['g', 32], ['h', 33], ['i', 34], ['j', 35],\n        ['k', 36], ['l', 37], ['m', 38], ['n', 39], ['o', 40], ['p', 41],\n        ['q', 42], ['r', 43], ['s', 44], ['t', 45], ['u', 46], ['v', 47],\n        ['w', 48], ['x', 49], ['y', 50], ['z', 51], ['0', 52], ['1', 53],\n        ['2', 54], ['3', 55], ['4', 56], ['5', 57], ['6', 58], ['7', 59],\n        ['8', 60], ['9', 61], ['-', 62], ['_', 63],\n    ]);\n    /**\n     * log2(64) = 6\n     */\n    static BASIS = 6;\n    static LCM = 24;\n    /**\n     * encodes an arbitrary-length bitfield string into base64url\n     *\n     * @static\n     * @param {string} str - arbitrary-length bitfield string to be encoded to base64url\n     * @return {string} - base64url encoded result\n     */\n    static encode(str) {\n        /**\n         * should only be 0 or 1\n         */\n        if (!/^[0-1]+$/.test(str)) {\n            throw new EncodingError('Invalid bitField');\n        }\n        /**\n         * Pad the end of the string to the least common mutliple of 6 (basis for\n         * base64) and 8 (one byte)\n         */\n        const padding = str.length % this.LCM;\n        str += padding ? '0'.repeat(this.LCM - padding) : '';\n        let result = '';\n        for (let i = 0; i < str.length; i += this.BASIS) {\n            result += this.DICT[parseInt(str.substr(i, this.BASIS), 2)];\n        }\n        return result;\n    }\n    /**\n     * decodes a base64url encoded bitfield string\n     *\n     * @static\n     * @param {string} str - base64url encoded bitfield string to be decoded\n     * @return {string} - bitfield string\n     */\n    static decode(str) {\n        /**\n         * should contain only characters from the base64url set\n         */\n        if (!/^[A-Za-z0-9\\-_]+$/.test(str)) {\n            throw new DecodingError('Invalidly encoded Base64URL string');\n        }\n        let result = '';\n        for (let i = 0; i < str.length; i++) {\n            /**\n             * index the binary value of the character from out reverse map\n             */\n            const strBits = this.REVERSE_DICT.get(str[i]).toString(2);\n            /**\n             * Since a bit string converted to an integer on encoding will lose\n             * leading zeros â€“ pad to the left for those missing leading zeros\n             */\n            result += '0'.repeat(this.BASIS - strBits.length) + strBits;\n        }\n        return result;\n    }\n}\n","/**\n * Abstract Class Cloneable<T> can be extended to give the child class the ability to clone its self.\n * The child class must pass its class to super. You can then pass any needed arguments to help build\n * the cloned class to the protected _clone() method.\n *\n * Example:\n *\n * class Example extends Cloneable<Example> {\n *\n * }\n * Todo: There must be more non primitive build in types to check. But for our current purposes, this works great.\n */\nexport class Cloneable {\n    /**\n     * clone - returns a copy of the classes with new values and not references\n     *\n     * @return {T}\n     */\n    clone() {\n        const myClone = new this.constructor();\n        const keys = Object.keys(this);\n        keys.forEach((key) => {\n            const value = this.deepClone(this[key]);\n            if (value !== undefined) {\n                myClone[key] = value;\n            }\n        });\n        return myClone;\n    }\n    ;\n    /**\n     * deepClone - recursive function that makes copies of reference values\n     *\n     * @param {unknown} item\n     * @return {unknown}\n     */\n    deepClone(item) {\n        const itsType = typeof item;\n        if (itsType === 'number' || itsType === 'string' || itsType === 'boolean') {\n            return item;\n        }\n        else if (item !== null && itsType === 'object') {\n            if (typeof item.clone === 'function') {\n                return item.clone();\n            }\n            else if (item instanceof Date) {\n                return new Date(item.getTime());\n            }\n            else if (item[Symbol.iterator] !== undefined) {\n                const ar = [];\n                for (const subItem of item) {\n                    ar.push(this.deepClone(subItem));\n                }\n                if (item instanceof Array) {\n                    return ar;\n                }\n                else {\n                    return new item.constructor(ar);\n                }\n            }\n            else {\n                const retr = {};\n                for (const prop in item) {\n                    if (item.hasOwnProperty(prop)) {\n                        retr[prop] = this.deepClone(item[prop]);\n                    }\n                }\n                return retr;\n            }\n        }\n        /**\n         * ignore functions because those will be initialized with the cloning\n         * process\n         */\n    }\n}\n","import { Cloneable } from '../Cloneable.js';\nexport class BinarySearchTree extends Cloneable {\n    root = null;\n    getRoot() {\n        return this.root;\n    }\n    isEmpty() {\n        // if root is undefined or null then by definition this is empty\n        return !(this.root);\n    }\n    add(value) {\n        // create new node object\n        const node = {\n            value: value,\n            left: null,\n            right: null,\n        };\n        let current;\n        // first item?\n        if (this.isEmpty()) {\n            this.root = node;\n        }\n        else {\n            // start at the root\n            current = this.root;\n            // infinite loop, figure out where to put it\n            while (true) {\n                // if the value is less than current value; go left\n                if (value < current.value) {\n                    // if it's empty, we can insert\n                    if (current.left === null) {\n                        // insert on the left\n                        current.left = node;\n                        // our work is done here\n                        break;\n                    }\n                    else {\n                        /**\n                         * if there's something there already, we'll reset the pointer and\n                         * wait for the next loop to do something ie. keep traversing\n                         */\n                        current = current.left;\n                    }\n                }\n                else if (value > current.value) {\n                    // if the value is greater than our current value; go right\n                    if (current.right === null) {\n                        // there's nothing to the right, so put it here\n                        current.right = node;\n                        break;\n                    }\n                    else {\n                        /**\n                         * if there's something there already, we'll reset the pointer and\n                         * wait for the next loop to do something ie. keep traversing\n                         */\n                        current = current.right;\n                    }\n                }\n                else {\n                    /**\n                     * If it's neither greater than the right or less than the right then\n                     * it is equal to the current nodes value.  In that case we won't do\n                     * anything with it because we will only insert unique values.\n                     */\n                    break;\n                }\n            }\n        }\n    }\n    /**\n     * performs Morris in-order traversal\n     * @return {number[]} sorted array\n     */\n    get() {\n        const retr = [];\n        let current = this.root;\n        while (current) {\n            if (!current.left) {\n                retr.push(current.value); // if there is no left child, visit current node\n                current = current.right; // then we go the right branch\n            }\n            else {\n                // find the right most leaf of root.left node.\n                let pre = current.left;\n                // when pre.right == null, it means we go to the right most leaf\n                // when pre.right == current, it means the right most leaf has been visited in the last round\n                while (pre.right && pre.right != current) {\n                    pre = pre.right;\n                }\n                // this means the pre.right has been set, it's time to go to current node\n                if (pre.right == current) {\n                    pre.right = null;\n                    // means the current node is pointed by left right most child\n                    // the left branch has been visited, it's time to push the current node\n                    retr.push(current.value);\n                    current = current.right;\n                }\n                else {\n                    // the fist time to visit the pre node, make its right child point to current node\n                    pre.right = current;\n                    current = current.left;\n                }\n            }\n        }\n        return retr;\n    }\n    contains(value) {\n        let retr = false;\n        let current = this.root;\n        while (current) {\n            if (current.value === value) {\n                retr = true;\n                break;\n            }\n            else if (value > current.value) {\n                current = current.right;\n            }\n            else if (value < current.value) {\n                current = current.left;\n            }\n        }\n        return retr;\n    }\n    min(current = this.root) {\n        let retr;\n        while (current) {\n            if (current.left) {\n                current = current.left;\n            }\n            else {\n                retr = current.value;\n                current = null;\n            }\n        }\n        return retr;\n    }\n    max(current = this.root) {\n        let retr;\n        while (current) {\n            if (current.right) {\n                current = current.right;\n            }\n            else {\n                retr = current.value;\n                current = null;\n            }\n        }\n        return retr;\n    }\n    remove(value, current = this.root) {\n        // we start at the root, so the parent is null\n        let parent = null;\n        let parentSide = 'left';\n        while (current) {\n            if (value < current.value) {\n                // set our parent to the current value\n                parent = current;\n                // value is less than current value, so go left\n                current = current.left;\n                parentSide = 'left';\n            }\n            else if (value > current.value) {\n                // set our parent to the current value\n                parent = current;\n                // value is greater than current value, so go right\n                current = current.right;\n                parentSide = 'right';\n            }\n            else {\n                /**\n                   * if it's neither greater than or less than, then it's equal so BINGO!\n                   * we've found it\n                   *\n                   * If we have children, we've got to figure out what to do with\n                   * them once we are no longer around...  Woah, code is like real\n                   * life...\n                   *\n                   * There are three cases we care about when it comes to this removal\n                   * process:\n                   *\n                   * 1. No children -- If not children we just delete an do nothing\n                   * else, no harm no foul.\n                   *\n                   * 2. One child -- Just link the parent's link to current to the\n                   * child.\n                   *\n                   * 3. Two children --  Find the minimum value from the right subtree\n                   * replace us with the minimum value and of course remove that\n                   * minimum value from the right stubtree\n                   */\n                if (!current.left && !current.right) {\n                    // case 1 there are no children easy peasy lemon squeezy\n                    if (parent) {\n                        parent[parentSide] = null;\n                    }\n                    else {\n                        this.root = null;\n                    }\n                }\n                else if (!current.left) {\n                    // no left side only right, so link right\n                    if (parent) {\n                        parent[parentSide] = current.right;\n                    }\n                    else {\n                        this.root = current.right;\n                    }\n                }\n                else if (!current.right) {\n                    // no right side only left, so link left\n                    if (parent) {\n                        parent[parentSide] = current.left;\n                    }\n                    else {\n                        this.root = current.left;\n                    }\n                }\n                else {\n                    /**\n                     * case 3 just like real life, if you delete a parent the more kids\n                     * that parent has the more complicated things get... in this case we\n                     * have two children.  We're gonna have to figure out who goes where.\n                     */\n                    const minVal = this.min(current.right);\n                    // little bit of recursion...\n                    this.remove(minVal, current.right);\n                    current.value = minVal;\n                }\n                current = null;\n            }\n        }\n    }\n    /**\n     * Build Binary Search Tree from the ordered number array.\n     *  The depth of the tree will be the `log2` of the array length.\n     * @param {number[]} values number array in ascending order\n     * @return {BinarySearchTree} Binary Search Tree\n     */\n    static build(values) {\n        if (!values || values.length === 0) {\n            return null;\n        }\n        else if (values.length === 1) {\n            const tree = new BinarySearchTree();\n            tree.add(values[0]);\n            return tree;\n        }\n        else {\n            const rootIndex = values.length >> 1;\n            const tree = new BinarySearchTree();\n            tree.add(values[rootIndex]);\n            const root = tree.getRoot();\n            if (root) {\n                if (rootIndex + 1 < values.length) {\n                    const rightTree = BinarySearchTree.build(values.slice(rootIndex + 1));\n                    root.right = rightTree ? rightTree.getRoot() : null;\n                }\n                if (rootIndex - 1 > 0) {\n                    const leftTree = BinarySearchTree.build(values.slice(0, rootIndex - 1));\n                    root.left = leftTree ? leftTree.getRoot() : null;\n                }\n            }\n            return tree;\n        }\n    }\n}\n","export class ConsentLanguages {\n    static langSet = new Set([\n        'BG',\n        'CA',\n        'CS',\n        'DA',\n        'DE',\n        'EL',\n        'EN',\n        'ES',\n        'ET',\n        'FI',\n        'FR',\n        'HR',\n        'HU',\n        'IT',\n        'JA',\n        'LT',\n        'LV',\n        'MT',\n        'NL',\n        'NO',\n        'PL',\n        'PT',\n        'RO',\n        'RU',\n        'SK',\n        'SL',\n        'SV',\n        'TR',\n        'ZH',\n    ]);\n    has(key) {\n        return ConsentLanguages.langSet.has(key);\n    }\n    forEach(callback) {\n        ConsentLanguages.langSet.forEach(callback);\n    }\n    get size() {\n        return ConsentLanguages.langSet.size;\n    }\n}\n","export class Fields {\n    static cmpId = 'cmpId';\n    static cmpVersion = 'cmpVersion';\n    static consentLanguage = 'consentLanguage';\n    static consentScreen = 'consentScreen';\n    static created = 'created';\n    static supportOOB = 'supportOOB';\n    static isServiceSpecific = 'isServiceSpecific';\n    static lastUpdated = 'lastUpdated';\n    static numCustomPurposes = 'numCustomPurposes';\n    static policyVersion = 'policyVersion';\n    static publisherCountryCode = 'publisherCountryCode';\n    static publisherCustomConsents = 'publisherCustomConsents';\n    static publisherCustomLegitimateInterests = 'publisherCustomLegitimateInterests';\n    static publisherLegitimateInterests = 'publisherLegitimateInterests';\n    static publisherConsents = 'publisherConsents';\n    static publisherRestrictions = 'publisherRestrictions';\n    static purposeConsents = 'purposeConsents';\n    static purposeLegitimateInterests = 'purposeLegitimateInterests';\n    static purposeOneTreatment = 'purposeOneTreatment';\n    static specialFeatureOptins = 'specialFeatureOptins';\n    static useNonStandardStacks = 'useNonStandardStacks';\n    static vendorConsents = 'vendorConsents';\n    static vendorLegitimateInterests = 'vendorLegitimateInterests';\n    static vendorListVersion = 'vendorListVersion';\n    static vendorsAllowed = 'vendorsAllowed';\n    static vendorsDisclosed = 'vendorsDisclosed';\n    static version = 'version';\n}\n","/**\n * if a Vendor has declared flexible purposes (see: [[Vendor]] under\n * `flexiblePurposeIds`) on the Global Vendor List ([[Declarations]]) a CMP may\n * change their legal basis for processing in the encoding.\n */\nexport var RestrictionType;\n(function (RestrictionType) {\n    /**\n     * under no circumstances is this purpose allowed.\n     */\n    RestrictionType[RestrictionType[\"NOT_ALLOWED\"] = 0] = \"NOT_ALLOWED\";\n    /**\n     * if the default declaration is legitimate interest then this flips the purpose to consent in the encoding.\n     */\n    RestrictionType[RestrictionType[\"REQUIRE_CONSENT\"] = 1] = \"REQUIRE_CONSENT\";\n    /**\n     * if the default declaration is consent then this flips the purpose to Legitimate Interest in the encoding.\n     */\n    RestrictionType[RestrictionType[\"REQUIRE_LI\"] = 2] = \"REQUIRE_LI\";\n})(RestrictionType || (RestrictionType = {}));\n","export var DeviceDisclosureStorageAccessType;\n(function (DeviceDisclosureStorageAccessType) {\n    DeviceDisclosureStorageAccessType[\"COOKIE\"] = \"cookie\";\n    DeviceDisclosureStorageAccessType[\"WEB\"] = \"web\";\n    DeviceDisclosureStorageAccessType[\"APP\"] = \"app\";\n})(DeviceDisclosureStorageAccessType || (DeviceDisclosureStorageAccessType = {}));\n","export var Segment;\n(function (Segment) {\n    Segment[\"CORE\"] = \"core\";\n    Segment[\"VENDORS_DISCLOSED\"] = \"vendorsDisclosed\";\n    Segment[\"VENDORS_ALLOWED\"] = \"vendorsAllowed\";\n    Segment[\"PUBLISHER_TC\"] = \"publisherTC\";\n})(Segment || (Segment = {}));\n","export var VectorEncodingType;\n(function (VectorEncodingType) {\n    VectorEncodingType[VectorEncodingType[\"FIELD\"] = 0] = \"FIELD\";\n    VectorEncodingType[VectorEncodingType[\"RANGE\"] = 1] = \"RANGE\";\n})(VectorEncodingType || (VectorEncodingType = {}));\n","import { Cloneable } from '../Cloneable.js';\nimport { TCModelError } from '../errors/index.js';\nimport { RestrictionType } from './RestrictionType.js';\nexport class PurposeRestriction extends Cloneable {\n    static hashSeparator = '-';\n    purposeId_;\n    restrictionType;\n    /**\n     * constructor\n     *\n     * @param {number} purposeId? - may optionally pass the purposeId into the\n     * constructor\n     * @param {RestrictionType} restrictionType? - may\n     * optionally pass the restrictionType into the constructor\n     * @return {undefined}\n     */\n    constructor(purposeId, restrictionType) {\n        super();\n        if (purposeId !== undefined) {\n            this.purposeId = purposeId;\n        }\n        if (restrictionType !== undefined) {\n            this.restrictionType = restrictionType;\n        }\n    }\n    static unHash(hash) {\n        const splitUp = hash.split(this.hashSeparator);\n        const purpRestriction = new PurposeRestriction();\n        if (splitUp.length !== 2) {\n            throw new TCModelError('hash', hash);\n        }\n        purpRestriction.purposeId = parseInt(splitUp[0], 10);\n        purpRestriction.restrictionType = parseInt(splitUp[1], 10);\n        return purpRestriction;\n    }\n    get hash() {\n        if (!this.isValid()) {\n            throw new Error('cannot hash invalid PurposeRestriction');\n        }\n        return `${this.purposeId}${PurposeRestriction.hashSeparator}${this.restrictionType}`;\n    }\n    /**\n     * @return {number} The purpose Id associated with a publisher\n     * purpose-by-vendor restriction that resulted in a different consent or LI\n     * status than the consent or LI purposes allowed lists.\n     */\n    get purposeId() {\n        return this.purposeId_;\n    }\n    /**\n     * @param {number} idNum - The purpose Id associated with a publisher\n     * purpose-by-vendor restriction that resulted in a different consent or LI\n     * status than the consent or LI purposes allowed lists.\n     */\n    set purposeId(idNum) {\n        this.purposeId_ = idNum;\n    }\n    isValid() {\n        return (Number.isInteger(this.purposeId) &&\n            this.purposeId > 0 &&\n            (this.restrictionType === RestrictionType.NOT_ALLOWED ||\n                this.restrictionType === RestrictionType.REQUIRE_CONSENT ||\n                this.restrictionType === RestrictionType.REQUIRE_LI));\n    }\n    isSameAs(otherPR) {\n        return (this.purposeId === otherPR.purposeId &&\n            this.restrictionType === otherPR.restrictionType);\n    }\n}\n","import { PurposeRestriction } from './PurposeRestriction.js';\nimport { BinarySearchTree } from './BinarySearchTree.js';\nimport { RestrictionType } from './RestrictionType.js';\nimport { Cloneable } from '../Cloneable.js';\nexport class PurposeRestrictionVector extends Cloneable {\n    /**\n     * if this originatd from an encoded string we'll need a place to store the\n     * bit length; it can be set and got from here\n     */\n    bitLength = 0;\n    /**\n     * a map indexed by a string which will be a 'hash' of the purpose and\n     * restriction type.\n     *\n     * Using a BST to keep vendors in a sorted order for encoding later\n     */\n    map = new Map();\n    gvl_;\n    has(hash) {\n        return this.map.has(hash);\n    }\n    isOkToHave(restrictionType, purposeId, vendorId) {\n        let result = true;\n        /**\n         * without a gvl set, there's no way to know... in that case we'll return\n         * true but once the GVL is set later we'll go through these and clean up\n         * the mess.\n         */\n        if (this.gvl?.vendors) {\n            const vendor = this.gvl.vendors[vendorId];\n            if (vendor) {\n                if (restrictionType === RestrictionType.NOT_ALLOWED) {\n                    /**\n                     * if it's \"not allowed\" then flexible declaration is ignored but if\n                     * if it isn't even listed as one of the purposes the vendor uses,\n                     * then there is no reason to encode the value so check both arrays\n                     * to see if it exists.  If it does then we can restrict it.\n                     */\n                    result = (vendor.legIntPurposes.includes(purposeId) || vendor.purposes.includes(purposeId));\n                }\n                else if (vendor.flexiblePurposes.length) {\n                    switch (restrictionType) {\n                        /**\n                         * If the vendor has the purposeId in flexiblePurposes and it is\n                         * listed as a legitimate interest purpose we can set the\n                         * override to require consent.\n                         */\n                        case RestrictionType.REQUIRE_CONSENT:\n                            result = (vendor.flexiblePurposes.includes(purposeId) && vendor.legIntPurposes.includes(purposeId));\n                            break;\n                        /**\n                         * If the vendor has the purposeId in flexiblePurposes and it is\n                         * listed as a consent purpose we can set the\n                         * override to require legitimate interest.\n                         */\n                        case RestrictionType.REQUIRE_LI:\n                            result = (vendor.flexiblePurposes.includes(purposeId) && vendor.purposes.includes(purposeId));\n                            break;\n                    }\n                }\n                else {\n                    result = false;\n                }\n            }\n            else {\n                // this vendor doesn't exist\n                result = false;\n            }\n        }\n        // if the gvl isn't defined, we can't do anything until later\n        return result;\n    }\n    /**\n     * add - adds a given Vendor ID under a given Purpose Restriction\n     *\n     * @param {number} vendorId\n     * @param {PurposeRestriction} purposeRestriction\n     * @return {void}\n     */\n    add(vendorId, purposeRestriction) {\n        if (this.isOkToHave(purposeRestriction.restrictionType, purposeRestriction.purposeId, vendorId)) {\n            const hash = purposeRestriction.hash;\n            if (!this.has(hash)) {\n                this.map.set(hash, new BinarySearchTree());\n                this.bitLength = 0;\n            }\n            /**\n             * Previously I had a check here to remove a duplicate value, but because\n             * we're using a tree the value is guaranteed to be unique so there is no\n             * need to add an additional de-duplication here.\n             */\n            this.map.get(hash).add(vendorId);\n        }\n    }\n    /**\n     * restrictPurposeToLegalBasis - adds all Vendors under a given Purpose Restriction\n     *\n     * @param {PurposeRestriction} purposeRestriction\n     * @return {void}\n     */\n    restrictPurposeToLegalBasis(purposeRestriction) {\n        const vendors = this.gvl.vendorIds;\n        const hash = purposeRestriction.hash;\n        const lastEntry = (function () {\n            let value;\n            for (value of vendors)\n                ;\n            return value;\n        })();\n        /**\n         * Create an ordered array of vendor IDs from `1` (the minimum value for Vendor ID) to `lastEntry`\n         */\n        const values = [...Array(lastEntry).keys()].map((i) => i + 1);\n        for (let i = 1; i <= lastEntry; i++) {\n            if (!this.has(hash)) {\n                this.map.set(hash, BinarySearchTree.build(values)); // use static method `build` to create a `BST` from the ordered array of IDs\n                this.bitLength = 0;\n            }\n            /**\n             * Previously I had a check here to remove a duplicate value, but because\n             * we're using a tree the value is guaranteed to be unique so there is no\n             * need to add an additional de-duplication here.\n             */\n            this.map.get(hash).add(i);\n        }\n    }\n    /**\n     * getVendors - returns array of vendor ids optionally narrowed by a given\n     * Purpose Restriction.  If no purpose restriction is passed then all vendor\n     * ids will be returned.  One can expect this result to be a unique set of\n     * ids no duplicates.\n     *\n     * @param {PurposeRestriction} [purposeRestriction] - optionally passed to\n     * get only Vendor IDs restricted under the given Purpose Restriction\n     * @return {number[]} - Unique ID set of vendors\n     */\n    getVendors(purposeRestriction) {\n        let vendorIds = [];\n        if (purposeRestriction) {\n            const hash = purposeRestriction.hash;\n            if (this.has(hash)) {\n                vendorIds = this.map.get(hash).get();\n            }\n        }\n        else {\n            const vendorSet = new Set();\n            this.map.forEach((bst) => {\n                bst.get().forEach((vendorId) => {\n                    vendorSet.add(vendorId);\n                });\n            });\n            vendorIds = Array.from(vendorSet);\n        }\n        return vendorIds;\n    }\n    getRestrictionType(vendorId, purposeId) {\n        let rType;\n        this.getRestrictions(vendorId).forEach((purposeRestriction) => {\n            if (purposeRestriction.purposeId === purposeId) {\n                if (rType === undefined || rType > purposeRestriction.restrictionType) {\n                    rType = purposeRestriction.restrictionType;\n                }\n            }\n        });\n        return rType;\n    }\n    /**\n     * vendorHasRestriction - determines whether a given Vendor ID is under a\n     * given Purpose Restriction\n     *\n     * @param {number} vendorId\n     * @param {PurposeRestriction} purposeRestriction\n     * @return {boolean} - true if the give Vendor ID is under the given Purpose\n     * Restriction\n     */\n    vendorHasRestriction(vendorId, purposeRestriction) {\n        let has = false;\n        const restrictions = this.getRestrictions(vendorId);\n        for (let i = 0; i < restrictions.length && !has; i++) {\n            has = purposeRestriction.isSameAs(restrictions[i]);\n        }\n        return has;\n    }\n    /**\n     * getMaxVendorId - gets the Maximum Vendor ID regardless of Purpose\n     * Restriction\n     *\n     * @return {number} - maximum Vendor ID\n     */\n    getMaxVendorId() {\n        let retr = 0;\n        this.map.forEach((bst) => {\n            retr = Math.max(bst.max(), retr);\n        });\n        return retr;\n    }\n    getRestrictions(vendorId) {\n        const retr = [];\n        this.map.forEach((bst, hash) => {\n            if (vendorId) {\n                if (bst.contains(vendorId)) {\n                    retr.push(PurposeRestriction.unHash(hash));\n                }\n            }\n            else {\n                retr.push(PurposeRestriction.unHash(hash));\n            }\n        });\n        return retr;\n    }\n    getPurposes() {\n        const purposeIds = new Set();\n        this.map.forEach((bst, hash) => {\n            purposeIds.add(PurposeRestriction.unHash(hash).purposeId);\n        });\n        return Array.from(purposeIds);\n    }\n    /**\n     * remove - removes Vendor ID from a Purpose Restriction\n     *\n     * @param {number} vendorId\n     * @param {PurposeRestriction} purposeRestriction\n     * @return {void}\n     */\n    remove(vendorId, purposeRestriction) {\n        const hash = purposeRestriction.hash;\n        const bst = this.map.get(hash);\n        if (bst) {\n            bst.remove(vendorId);\n            // if it's empty let's delete the key so it doesn't show up empty\n            if (bst.isEmpty()) {\n                this.map.delete(hash);\n                this.bitLength = 0;\n            }\n        }\n    }\n    /**\n     * Essential for being able to determine whether we can actually set a\n     * purpose restriction since they have to have a flexible legal basis\n     *\n     * @param {GVL} value - the GVL instance\n     */\n    set gvl(value) {\n        if (!this.gvl_) {\n            this.gvl_ = value;\n            /**\n             * if we have restrictions set before the gvl is set then we'll have to\n             * go through and remove some if they're not valid\n             */\n            this.map.forEach((bst, hash) => {\n                const purposeRestriction = PurposeRestriction.unHash(hash);\n                const vendors = bst.get();\n                vendors.forEach((vendorId) => {\n                    if (!this.isOkToHave(purposeRestriction.restrictionType, purposeRestriction.purposeId, vendorId)) {\n                        bst.remove(vendorId);\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * gvl returns local copy of the GVL these restrictions apply to\n     *\n     * @return {GVL}\n     */\n    get gvl() {\n        return this.gvl_;\n    }\n    /**\n     * isEmpty - whether or not this vector has any restrictions in it\n     *\n     * @return {boolean}\n     */\n    isEmpty() {\n        return this.map.size === 0;\n    }\n    ;\n    /**\n     * numRestrictions - returns the number of Purpose Restrictions.\n     *\n     * @return {number}\n     */\n    get numRestrictions() {\n        return this.map.size;\n    }\n}\n","import { Segment } from './Segment.js';\nexport class SegmentIDs {\n    /**\n     * 0 = default - reserved for core string (does not need to be present in the core string)\n     * 1 = OOB vendors disclosed\n     * 2 = OOB vendors allowed\n     * 3 = PublisherTC\n     */\n    static ID_TO_KEY = [\n        Segment.CORE,\n        Segment.VENDORS_DISCLOSED,\n        Segment.VENDORS_ALLOWED,\n        Segment.PUBLISHER_TC,\n    ];\n    static KEY_TO_ID = {\n        [Segment.CORE]: 0,\n        [Segment.VENDORS_DISCLOSED]: 1,\n        [Segment.VENDORS_ALLOWED]: 2,\n        [Segment.PUBLISHER_TC]: 3,\n    };\n}\n","import { Cloneable } from '../Cloneable.js';\nimport { TCModelError } from '../errors/index.js';\n/**\n * Vector class is like a Set except it keeps track of a max id\n */\nexport class Vector extends Cloneable {\n    /**\n     * if this originatd from an encoded string we'll need a place to store the\n     * bit length; it can be set and got from here\n     */\n    bitLength = 0;\n    maxId_ = 0;\n    set_ = new Set();\n    *[Symbol.iterator]() {\n        for (let i = 1; i <= this.maxId; i++) {\n            yield [i, this.has(i)];\n        }\n    }\n    /**\n     * values()\n     *\n     * @return {IterableIterator<number>} - returns an iterator of the positive\n     * values in the set\n     */\n    values() {\n        return this.set_.values();\n    }\n    /**\n     * maxId\n     *\n     * @return {number} - the highest id in this Vector\n     */\n    get maxId() {\n        return this.maxId_;\n    }\n    /**\n     * get\n     *\n     * @param {number} id - key for value to check\n     * @return {boolean} - value of that key, if never set it will be false\n     */\n    has(id) {\n        /**\n         * if it exists in the set we'll return true\n         */\n        return this.set_.has(id);\n    }\n    /**\n     * unset\n     *\n     * @param {SingleIDOrCollection} id - id or ids to unset\n     * @return {void}\n     */\n    unset(id) {\n        if (Array.isArray(id)) {\n            id.forEach((id) => this.unset(id));\n        }\n        else if (typeof id === 'object') {\n            this.unset(Object.keys(id).map((strId) => Number(strId)));\n        }\n        else {\n            this.set_.delete(Number(id));\n            /**\n             * if bitLength was set before, it must now be unset\n             */\n            this.bitLength = 0;\n            if (id === this.maxId) {\n                /**\n                 * aww bummer we lost our maxId... now we've got to search through\n                 * all the ids and find the biggest one.\n                 */\n                this.maxId_ = 0;\n                this.set_.forEach((id) => {\n                    this.maxId_ = Math.max(this.maxId, id);\n                });\n            }\n        }\n    }\n    isIntMap(item) {\n        let result = (typeof item === 'object');\n        result = (result && Object.keys(item).every((key) => {\n            let itemResult = Number.isInteger(parseInt(key, 10));\n            itemResult = (itemResult && this.isValidNumber(item[key].id));\n            itemResult = (itemResult && item[key].name !== undefined);\n            return itemResult;\n        }));\n        return result;\n    }\n    isValidNumber(item) {\n        return (parseInt(item, 10) > 0);\n    }\n    isSet(item) {\n        let result = false;\n        if (item instanceof Set) {\n            result = Array.from(item).every(this.isValidNumber);\n        }\n        return result;\n    }\n    /**\n     * set - sets an item assumed to be a truthy value by its presence\n     *\n     * @param {SingleIDOrCollection} item - May be a single id (positive integer)\n     * or collection of ids in a set, GVL Int Map, or Array.\n     *\n     * @return {void}\n     */\n    set(item) {\n        /**\n         * strategy here is to just recursively call set if it's a collection until\n         * we get to the final integer ID\n         */\n        if (Array.isArray(item)) {\n            item.forEach((item) => this.set(item));\n        }\n        else if (this.isSet(item)) {\n            this.set(Array.from(item));\n        }\n        else if (this.isIntMap(item)) {\n            this.set(Object.keys(item).map((strId) => Number(strId)));\n        }\n        else if (this.isValidNumber(item)) {\n            this.set_.add(item);\n            this.maxId_ = Math.max(this.maxId, item);\n            /**\n             * if bitLength was set before, it must now be unset\n             */\n            this.bitLength = 0;\n        }\n        else {\n            /**\n             * Super not cool to try and set something that's not valid\n             */\n            throw new TCModelError('set()', item, 'must be positive integer array, positive integer, Set<number>, or IntMap');\n        }\n    }\n    empty() {\n        this.set_ = new Set();\n    }\n    /**\n     * forEach - to traverse from id=1 to id=maxId in a sequential non-sparse manner\n     *\n     *\n     * @param {forEachCallback} callback - callback to execute\n     * @return {void}\n     *\n     * @callback forEachCallback\n     * @param {boolean} value - whether or not this id exists in the vector\n     * @param {number} id - the id number of the current iteration\n     */\n    forEach(callback) {\n        for (let i = 1; i <= this.maxId; i++) {\n            callback(this.has(i), i);\n        }\n    }\n    get size() {\n        return this.set_.size;\n    }\n    setAll(intMap) {\n        this.set(intMap);\n    }\n}\n","import { Fields } from '../model/index.js';\nexport class BitLength {\n    static [Fields.cmpId] = 12;\n    static [Fields.cmpVersion] = 12;\n    static [Fields.consentLanguage] = 12;\n    static [Fields.consentScreen] = 6;\n    static [Fields.created] = 36;\n    static [Fields.isServiceSpecific] = 1;\n    static [Fields.lastUpdated] = 36;\n    static [Fields.policyVersion] = 6;\n    static [Fields.publisherCountryCode] = 12;\n    static [Fields.publisherLegitimateInterests] = 24;\n    static [Fields.publisherConsents] = 24;\n    static [Fields.purposeConsents] = 24;\n    static [Fields.purposeLegitimateInterests] = 24;\n    static [Fields.purposeOneTreatment] = 1;\n    static [Fields.specialFeatureOptins] = 12;\n    static [Fields.useNonStandardStacks] = 1;\n    static [Fields.vendorListVersion] = 12;\n    static [Fields.version] = 6;\n    static anyBoolean = 1;\n    static encodingType = 1;\n    static maxId = 16;\n    static numCustomPurposes = 6;\n    static numEntries = 12;\n    static numRestrictions = 12;\n    static purposeId = 6;\n    static restrictionType = 2;\n    static segmentType = 3;\n    static singleOrRange = 1;\n    static vendorId = 16;\n}\n","export class BooleanEncoder {\n    static encode(value) {\n        return String(Number(value));\n    }\n    static decode(value) {\n        // less operations than !!parseInt(value, 2)\n        return value === '1';\n    }\n}\n","import { EncodingError, DecodingError, } from '../../errors/index.js';\nexport class IntEncoder {\n    static encode(value, numBits) {\n        let bitString;\n        if (typeof value === 'string') {\n            value = parseInt(value, 10);\n        }\n        bitString = value.toString(2);\n        if (bitString.length > numBits || value < 0) {\n            throw new EncodingError(`${value} too large to encode into ${numBits}`);\n        }\n        // Pad the string if not filling all bits\n        if (bitString.length < numBits) {\n            // pad left\n            bitString = '0'.repeat(numBits - bitString.length) + bitString;\n        }\n        return bitString;\n    }\n    static decode(value, numBits) {\n        if (numBits !== value.length) {\n            throw new DecodingError('invalid bit length');\n        }\n        return parseInt(value, 2);\n    }\n}\n","import { IntEncoder, } from './IntEncoder.js';\nimport { DecodingError, } from '../../errors/index.js';\nexport class DateEncoder {\n    static encode(value, numBits) {\n        return IntEncoder.encode(Math.round(value.getTime() / 100), numBits);\n    }\n    static decode(value, numBits) {\n        if (numBits !== value.length) {\n            throw new DecodingError('invalid bit length');\n        }\n        const date = new Date();\n        date.setTime(IntEncoder.decode(value, numBits) * 100);\n        return date;\n    }\n}\n","import { BooleanEncoder } from './BooleanEncoder.js';\nimport { DecodingError } from '../../errors/index.js';\nimport { Vector } from '../../model/index.js';\nexport class FixedVectorEncoder {\n    static encode(value, numBits) {\n        let bitString = '';\n        for (let i = 1; i <= numBits; i++) {\n            bitString += BooleanEncoder.encode(value.has(i));\n        }\n        return bitString;\n    }\n    static decode(value, numBits) {\n        if (value.length !== numBits) {\n            throw new DecodingError('bitfield encoding length mismatch');\n        }\n        const vector = new Vector();\n        for (let i = 1; i <= numBits; i++) {\n            if (BooleanEncoder.decode(value[i - 1])) {\n                vector.set(i);\n            }\n        }\n        vector.bitLength = value.length;\n        return vector;\n    }\n}\n","import { IntEncoder, } from './IntEncoder.js';\nimport { DecodingError, EncodingError, } from '../../errors/index.js';\nexport class LangEncoder {\n    static encode(value, numBits) {\n        value = value.toUpperCase();\n        const ASCII_START = 65;\n        const firstLetter = value.charCodeAt(0) - ASCII_START;\n        const secondLetter = value.charCodeAt(1) - ASCII_START;\n        // check some things to throw some good errors\n        if (firstLetter < 0 || firstLetter > 25 || secondLetter < 0 || secondLetter > 25) {\n            throw new EncodingError(`invalid language code: ${value}`);\n        }\n        if (numBits % 2 === 1) {\n            throw new EncodingError(`numBits must be even, ${numBits} is not valid`);\n        }\n        numBits = numBits / 2;\n        const firstLetterBString = IntEncoder.encode(firstLetter, numBits);\n        const secondLetterBString = IntEncoder.encode(secondLetter, numBits);\n        return firstLetterBString + secondLetterBString;\n    }\n    static decode(value, numBits) {\n        let retr;\n        // is it an even number of bits? we have to divide it\n        if (numBits === value.length && !(value.length % 2)) {\n            const ASCII_START = 65;\n            const mid = value.length / 2;\n            const firstLetter = IntEncoder.decode(value.slice(0, mid), mid) + ASCII_START;\n            const secondLetter = IntEncoder.decode(value.slice(mid), mid) + ASCII_START;\n            retr = String.fromCharCode(firstLetter) + String.fromCharCode(secondLetter);\n        }\n        else {\n            throw new DecodingError('invalid bit length for language');\n        }\n        return retr;\n    }\n}\n","import { BitLength } from '../BitLength.js';\nimport { BooleanEncoder } from './BooleanEncoder.js';\nimport { DecodingError } from '../../errors/index.js';\nimport { IntEncoder } from './IntEncoder.js';\nimport { PurposeRestrictionVector, PurposeRestriction } from '../../model/index.js';\nexport class PurposeRestrictionVectorEncoder {\n    static encode(prVector) {\n        // start with the number of restrictions\n        let bitString = IntEncoder.encode(prVector.numRestrictions, BitLength.numRestrictions);\n        // if the vector is empty we'll just return a string with just the numRestricitons being 0\n        if (!prVector.isEmpty()) {\n            // create each restriction group\n            prVector.getRestrictions().forEach((purpRestriction) => {\n                // every restriction group has the purposeId and the restrictionType;\n                bitString += IntEncoder.encode(purpRestriction.purposeId, BitLength.purposeId);\n                bitString += IntEncoder.encode(purpRestriction.restrictionType, BitLength.restrictionType);\n                // now get all the vendors under that restriction\n                const vendors = prVector.getVendors(purpRestriction);\n                const len = vendors.length;\n                /**\n                 * numEntries comes first so we will have to keep a counter and the do\n                 * the encoding at the end\n                 */\n                let numEntries = 0;\n                let startId = 0;\n                let rangeField = '';\n                for (let i = 0; i < len; i++) {\n                    const vendorId = vendors[i];\n                    if (startId === 0) {\n                        numEntries++;\n                        startId = vendorId;\n                    }\n                    // we know that `len` is greater than zero because we entered the loop\n                    const lastVendorId = vendors[len - 1];\n                    const gvlVendorIds = prVector.gvl.vendorIds;\n                    const nextGvlVendor = (vendorId) => {\n                        while (++vendorId <= lastVendorId && !gvlVendorIds.has(vendorId)) {\n                        }\n                        return vendorId;\n                    };\n                    /**\n                     * either end of the loop or there are GVL vendor IDs before the next one\n                     */\n                    if (i === len - 1 || vendors[i + 1] > nextGvlVendor(vendorId)) {\n                        /**\n                         * it's a range entry if we've got something other than the start\n                         * ID\n                         */\n                        const isRange = !(vendorId === startId);\n                        // 0 means single 1 means range\n                        rangeField += BooleanEncoder.encode(isRange);\n                        rangeField += IntEncoder.encode(startId, BitLength.vendorId);\n                        if (isRange) {\n                            rangeField += IntEncoder.encode(vendorId, BitLength.vendorId);\n                        }\n                        // reset the startId so we grab the next id in the list\n                        startId = 0;\n                    }\n                }\n                /**\n                 * now that  the range encoding is built, encode the number of ranges\n                 * and then append the range field to the bitString.\n                 */\n                bitString += IntEncoder.encode(numEntries, BitLength.numEntries);\n                bitString += rangeField;\n            });\n        }\n        return bitString;\n    }\n    static decode(encodedString) {\n        let index = 0;\n        const vector = new PurposeRestrictionVector();\n        const numRestrictions = IntEncoder.decode(encodedString.substr(index, BitLength.numRestrictions), BitLength.numRestrictions);\n        index += BitLength.numRestrictions;\n        for (let i = 0; i < numRestrictions; i++) {\n            // First is purpose ID\n            const purposeId = IntEncoder.decode(encodedString.substr(index, BitLength.purposeId), BitLength.purposeId);\n            index += BitLength.purposeId;\n            // Second Restriction Type\n            const restrictionType = IntEncoder.decode(encodedString.substr(index, BitLength.restrictionType), BitLength.restrictionType);\n            index += BitLength.restrictionType;\n            const purposeRestriction = new PurposeRestriction(purposeId, restrictionType);\n            // Num Entries (number of vendors)\n            const numEntries = IntEncoder.decode(encodedString.substr(index, BitLength.numEntries), BitLength.numEntries);\n            index += BitLength.numEntries;\n            for (let j = 0; j < numEntries; j++) {\n                const isARange = BooleanEncoder.decode(encodedString.substr(index, BitLength.anyBoolean));\n                index += BitLength.anyBoolean;\n                const startOrOnlyVendorId = IntEncoder.decode(encodedString.substr(index, BitLength.vendorId), BitLength.vendorId);\n                index += BitLength.vendorId;\n                if (isARange) {\n                    const endVendorId = IntEncoder.decode(encodedString.substr(index, BitLength.vendorId), BitLength.vendorId);\n                    index += BitLength.vendorId;\n                    if (endVendorId < startOrOnlyVendorId) {\n                        throw new DecodingError(`Invalid RangeEntry: endVendorId ${endVendorId} is less than ${startOrOnlyVendorId}`);\n                    }\n                    for (let k = startOrOnlyVendorId; k <= endVendorId; k++) {\n                        vector.add(k, purposeRestriction);\n                    }\n                }\n                else {\n                    vector.add(startOrOnlyVendorId, purposeRestriction);\n                }\n            }\n        }\n        vector.bitLength = index;\n        return vector;\n    }\n}\n","import { Vector } from '../../model/index.js';\nimport { BitLength } from '../index.js';\nimport { IntEncoder } from './IntEncoder.js';\nimport { BooleanEncoder } from './BooleanEncoder.js';\nimport { FixedVectorEncoder } from './FixedVectorEncoder.js';\nimport { VectorEncodingType } from './VectorEncodingType.js';\nimport { DecodingError } from '../../errors/index.js';\nexport class VendorVectorEncoder {\n    static encode(value) {\n        // collectors for range encoding\n        const ranges = [];\n        let range = [];\n        // since both encodings need the maxId, start with that\n        let retrString = IntEncoder.encode(value.maxId, BitLength.maxId);\n        // bit field will be just the vendors as we walk through the vector\n        let bitField = '';\n        let rangeIsSmaller;\n        // some math\n        const headerLength = BitLength.maxId + BitLength.encodingType;\n        const bitFieldLength = headerLength + value.maxId;\n        const minRangeLength = (BitLength.vendorId * 2 + BitLength.singleOrRange + BitLength.numEntries);\n        // gets larger as we walk through the vector\n        let rangeLength = headerLength + BitLength.numEntries;\n        // walk through every value in the vector\n        value.forEach((curValue, i) => {\n            // build our bitfield no matter what\n            bitField += BooleanEncoder.encode(curValue);\n            /**\n             * A range is a minimum of 45 bits, if the number of vendors in this\n             * vector is less than 45 then we know that a bitfield encoding will be\n             * shorter than any range encoding.\n             *\n             * The second check checks while we walk through the vector and abandons\n             * building the ranges once it becomes larger\n             */\n            rangeIsSmaller = (value.maxId > minRangeLength && rangeLength < bitFieldLength);\n            /**\n             * if the curValue is true and our rangeLength is less than the bitField\n             * length, we'll continue to push these ranges into the array.  Once the\n             * ranges become a larger encoding there is no reason to continue\n             * building the structure because we will be choosing the bitfield\n             * encoding\n             */\n            if (rangeIsSmaller && curValue) {\n                /**\n                 * Look ahead to see if this is the last value in our range\n                 */\n                const nextValue = value.has(i + 1);\n                // if there isn't a next value, then we'll wrap up this range\n                if (!nextValue) {\n                    /**\n                     * this is the last value of the range, so we'll push it on to the\n                     * end into position 1\n                     */\n                    range.push(i);\n                    // add to the range length the additional vendorId\n                    rangeLength += BitLength.vendorId;\n                    // store the array in our bigger array\n                    ranges.push(range);\n                    // clear the array for the next range\n                    range = [];\n                }\n                else if (range.length === 0) {\n                    // this is the first  value for this range\n                    range.push(i);\n                    // update our count with new range overhead\n                    rangeLength += BitLength.singleOrRange;\n                    rangeLength += BitLength.vendorId;\n                }\n            }\n        });\n        if (rangeIsSmaller) {\n            retrString += String(VectorEncodingType.RANGE);\n            retrString += this.buildRangeEncoding(ranges);\n        }\n        else {\n            retrString += String(VectorEncodingType.FIELD);\n            retrString += bitField;\n        }\n        return retrString;\n    }\n    static decode(value, version) {\n        let vector;\n        let index = 0;\n        const maxId = IntEncoder.decode(value.substr(index, BitLength.maxId), BitLength.maxId);\n        index += BitLength.maxId;\n        const encodingType = IntEncoder.decode(value.charAt(index), BitLength.encodingType);\n        index += BitLength.encodingType;\n        /**\n         * Range is handled in batches so we'll need a different decoding scheme\n         */\n        if (encodingType === VectorEncodingType.RANGE) {\n            vector = new Vector();\n            if (version === 1) {\n                if (value.substr(index, 1) === '1') {\n                    throw new DecodingError('Unable to decode default consent=1');\n                }\n                // jump over the default encoding\n                index++;\n            }\n            const numEntries = IntEncoder.decode(value.substr(index, BitLength.numEntries), BitLength.numEntries);\n            index += BitLength.numEntries;\n            // loop through each group of entries\n            for (let i = 0; i < numEntries; i++) {\n                // Ranges can represent a single id or a range of ids.\n                const isIdRange = BooleanEncoder.decode(value.charAt(index));\n                index += BitLength.singleOrRange;\n                /**\n                 * regardless of whether or not it's a single entry or range, the next\n                 * set of bits is a vendor ID\n                 */\n                const firstId = IntEncoder.decode(value.substr(index, BitLength.vendorId), BitLength.vendorId);\n                index += BitLength.vendorId;\n                // if it's a range, the next set of bits is the second id\n                if (isIdRange) {\n                    const secondId = IntEncoder.decode(value.substr(index, BitLength.vendorId), BitLength.vendorId);\n                    index += BitLength.vendorId;\n                    // we'll need to set or unset all the vendor ids between the first and second\n                    for (let j = firstId; j <= secondId; j++) {\n                        vector.set(j);\n                    }\n                }\n                else {\n                    vector.set(firstId);\n                }\n            }\n        }\n        else {\n            const bitField = value.substr(index, maxId);\n            index += maxId;\n            vector = FixedVectorEncoder.decode(bitField, maxId);\n        }\n        vector.bitLength = index;\n        return vector;\n    }\n    static buildRangeEncoding(ranges) {\n        // describe the number of entries to follow\n        const numEntries = ranges.length;\n        let rangeString = IntEncoder.encode(numEntries, BitLength.numEntries);\n        // each range\n        ranges.forEach((range) => {\n            // is this range a single?\n            const single = (range.length === 1);\n            // first is the indicator of whether this is a single id or range (two)\n            // 0 is single and range is 1\n            rangeString += BooleanEncoder.encode(!single);\n            // second is the first (or only) vendorId\n            rangeString += IntEncoder.encode(range[0], BitLength.vendorId);\n            if (!single) {\n                // add the second id if it exists\n                rangeString += IntEncoder.encode(range[1], BitLength.vendorId);\n            }\n        });\n        return rangeString;\n    }\n}\n","import { Fields } from '../../model/index.js';\nimport { BooleanEncoder } from './BooleanEncoder.js';\nimport { DateEncoder } from './DateEncoder.js';\nimport { FixedVectorEncoder } from './FixedVectorEncoder.js';\nimport { IntEncoder } from './IntEncoder.js';\nimport { LangEncoder } from './LangEncoder.js';\nimport { PurposeRestrictionVectorEncoder } from './PurposeRestrictionVectorEncoder.js';\nimport { VendorVectorEncoder } from './VendorVectorEncoder.js';\nexport function FieldEncoderMap() {\n    return {\n        [Fields.version]: IntEncoder,\n        [Fields.created]: DateEncoder,\n        [Fields.lastUpdated]: DateEncoder,\n        [Fields.cmpId]: IntEncoder,\n        [Fields.cmpVersion]: IntEncoder,\n        [Fields.consentScreen]: IntEncoder,\n        [Fields.consentLanguage]: LangEncoder,\n        [Fields.vendorListVersion]: IntEncoder,\n        [Fields.policyVersion]: IntEncoder,\n        [Fields.isServiceSpecific]: BooleanEncoder,\n        [Fields.useNonStandardStacks]: BooleanEncoder,\n        [Fields.specialFeatureOptins]: FixedVectorEncoder,\n        [Fields.purposeConsents]: FixedVectorEncoder,\n        [Fields.purposeLegitimateInterests]: FixedVectorEncoder,\n        [Fields.purposeOneTreatment]: BooleanEncoder,\n        [Fields.publisherCountryCode]: LangEncoder,\n        [Fields.vendorConsents]: VendorVectorEncoder,\n        [Fields.vendorLegitimateInterests]: VendorVectorEncoder,\n        [Fields.publisherRestrictions]: PurposeRestrictionVectorEncoder,\n        segmentType: IntEncoder,\n        [Fields.vendorsDisclosed]: VendorVectorEncoder,\n        [Fields.vendorsAllowed]: VendorVectorEncoder,\n        [Fields.publisherConsents]: FixedVectorEncoder,\n        [Fields.publisherLegitimateInterests]: FixedVectorEncoder,\n        [Fields.numCustomPurposes]: IntEncoder,\n        [Fields.publisherCustomConsents]: FixedVectorEncoder,\n        [Fields.publisherCustomLegitimateInterests]: FixedVectorEncoder,\n    };\n}\n","import { Segment, Fields } from '../../model/index.js';\nexport class FieldSequence {\n    '1' = {\n        [Segment.CORE]: [\n            Fields.version,\n            Fields.created,\n            Fields.lastUpdated,\n            Fields.cmpId,\n            Fields.cmpVersion,\n            Fields.consentScreen,\n            Fields.consentLanguage,\n            Fields.vendorListVersion,\n            Fields.purposeConsents,\n            Fields.vendorConsents,\n        ],\n    };\n    '2' = {\n        [Segment.CORE]: [\n            Fields.version,\n            Fields.created,\n            Fields.lastUpdated,\n            Fields.cmpId,\n            Fields.cmpVersion,\n            Fields.consentScreen,\n            Fields.consentLanguage,\n            Fields.vendorListVersion,\n            Fields.policyVersion,\n            Fields.isServiceSpecific,\n            Fields.useNonStandardStacks,\n            Fields.specialFeatureOptins,\n            Fields.purposeConsents,\n            Fields.purposeLegitimateInterests,\n            Fields.purposeOneTreatment,\n            Fields.publisherCountryCode,\n            Fields.vendorConsents,\n            Fields.vendorLegitimateInterests,\n            Fields.publisherRestrictions,\n        ],\n        [Segment.PUBLISHER_TC]: [\n            Fields.publisherConsents,\n            Fields.publisherLegitimateInterests,\n            Fields.numCustomPurposes,\n            Fields.publisherCustomConsents,\n            Fields.publisherCustomLegitimateInterests,\n        ],\n        [Segment.VENDORS_ALLOWED]: [\n            Fields.vendorsAllowed,\n        ],\n        [Segment.VENDORS_DISCLOSED]: [\n            Fields.vendorsDisclosed,\n        ],\n    };\n}\n","import { Segment, Fields, } from '../../model/index.js';\nexport class SegmentSequence {\n    '1' = [\n        Segment.CORE,\n    ];\n    '2' = [\n        Segment.CORE,\n    ];\n    constructor(tcModel, options) {\n        if (tcModel.version === 2) {\n            if (tcModel.isServiceSpecific) {\n                /**\n                 * If it's service specific only, then the publisher TC String can be\n                 * stored in the cookie and would be transmitted if it's not for\n                 * storage.  So it's included regardless of whether or not it's for\n                 * saving or the cmp api to surface.\n                 */\n                this['2'].push(Segment.PUBLISHER_TC);\n            }\n            else {\n                const isForVendors = !!(options && options.isForVendors);\n                /**\n                 * including vendors disclosed only if it is for saving (to the global\n                 * scope and not for vendors through the CMP API) or supportOOB is\n                 * turned on (either or both).  The compliment of this being not for\n                 * saving (surfaced to CMP) and no support of OOB.\n                 */\n                if (!isForVendors || tcModel[Fields.supportOOB] === true) {\n                    this['2'].push(Segment.VENDORS_DISCLOSED);\n                }\n                if (isForVendors) {\n                    /**\n                     * If a publisher does support OOB and they have narrowed the allowed\n                     * vendors to utilize it, then we should include the vendors allowed\n                     * segment.  If it is empty then there are no restrictions, if that\n                     * is intended to mean no support for OOB, then the flag should be\n                     * set for that instead.\n                     *\n                     */\n                    if (tcModel[Fields.supportOOB] && tcModel[Fields.vendorsAllowed].size > 0) {\n                        this['2'].push(Segment.VENDORS_ALLOWED);\n                    }\n                    /**\n                     * Always include the publisher TC segment as long as this TC string\n                     * is not intended to be saved in the global scope.\n                     */\n                    this['2'].push(Segment.PUBLISHER_TC);\n                }\n            }\n        }\n    }\n}\n","import { Base64Url } from './Base64Url.js';\nimport { BitLength } from './BitLength.js';\nimport { FieldEncoderMap, IntEncoder, VendorVectorEncoder } from './field/index.js';\nimport { FieldSequence } from './sequence/index.js';\nimport { EncodingError, DecodingError } from '../errors/index.js';\nimport { Fields } from '../model/Fields.js';\nimport { Segment, SegmentIDs } from '../model/index.js';\nexport class SegmentEncoder {\n    static fieldSequence = new FieldSequence();\n    static encode(tcModel, segment) {\n        let sequence;\n        try {\n            sequence = this.fieldSequence[String(tcModel.version)][segment];\n        }\n        catch (err) {\n            throw new EncodingError(`Unable to encode version: ${tcModel.version}, segment: ${segment}`);\n        }\n        let bitField = '';\n        /**\n         * If this is anything other than the core segment we have a \"segment id\"\n         * to append to the front of the string\n         */\n        if (segment !== Segment.CORE) {\n            bitField = IntEncoder.encode(SegmentIDs.KEY_TO_ID[segment], BitLength.segmentType);\n        }\n        const fieldEncoderMap = FieldEncoderMap();\n        sequence.forEach((key) => {\n            const value = tcModel[key];\n            const encoder = fieldEncoderMap[key];\n            let numBits = BitLength[key];\n            if (numBits === undefined) {\n                if (this.isPublisherCustom(key)) {\n                    /**\n                     * publisherCustom[Consents | LegitimateInterests] are an edge case\n                     * because they are of variable length. The length is defined in a\n                     * separate field named numCustomPurposes.\n                     */\n                    numBits = Number(tcModel[Fields.numCustomPurposes]);\n                }\n            }\n            try {\n                bitField += encoder.encode(value, numBits);\n            }\n            catch (err) {\n                throw new EncodingError(`Error encoding ${segment}->${key}: ${err.message}`);\n            }\n        });\n        // base64url encode the string and return\n        return Base64Url.encode(bitField);\n    }\n    static decode(encodedString, tcModel, segment) {\n        const bitField = Base64Url.decode(encodedString);\n        let bStringIdx = 0;\n        if (segment === Segment.CORE) {\n            tcModel.version = IntEncoder.decode(bitField.substr(bStringIdx, BitLength[Fields.version]), BitLength[Fields.version]);\n        }\n        if (segment !== Segment.CORE) {\n            bStringIdx += BitLength.segmentType;\n        }\n        const sequence = this.fieldSequence[String(tcModel.version)][segment];\n        const fieldEncoderMap = FieldEncoderMap();\n        sequence.forEach((key) => {\n            const encoder = fieldEncoderMap[key];\n            let numBits = BitLength[key];\n            if (numBits === undefined) {\n                if (this.isPublisherCustom(key)) {\n                    /**\n                     * publisherCustom[Consents | LegitimateInterests] are an edge case\n                     * because they are of variable length. The length is defined in a\n                     * separate field named numCustomPurposes.\n                     */\n                    numBits = Number(tcModel[Fields.numCustomPurposes]);\n                }\n            }\n            if (numBits !== 0) {\n                /**\n                 * numBits could be 0 if this is a publisher custom purposes field and\n                 * no custom purposes are defined. If that is the case, we don't need\n                 * to gather no bits and we don't need to increment our bStringIdx\n                 * pointer because those would all be 0 increments and would mess up\n                 * the next logical if statement.\n                 */\n                const bits = bitField.substr(bStringIdx, numBits);\n                if (encoder === VendorVectorEncoder) {\n                    tcModel[key] = encoder.decode(bits, tcModel.version);\n                }\n                else {\n                    tcModel[key] = encoder.decode(bits, numBits);\n                }\n                if (Number.isInteger(numBits)) {\n                    bStringIdx += numBits;\n                }\n                else if (Number.isInteger(tcModel[key].bitLength)) {\n                    bStringIdx += tcModel[key].bitLength;\n                }\n                else {\n                    throw new DecodingError(key);\n                }\n            }\n        });\n        return tcModel;\n    }\n    static isPublisherCustom(key) {\n        return key.indexOf('publisherCustom') === 0;\n    }\n}\n","import { EncodingError } from '../errors/index.js';\nimport { RestrictionType } from '../model/index.js';\nexport class SemanticPreEncoder {\n    static processor = [\n        (tcModel) => tcModel,\n        (tcModel, gvl) => {\n            /**\n             * in case this wasn't set previously.  This should filter out invalid\n             * purpose restrictions.\n             */\n            tcModel.publisherRestrictions.gvl = gvl;\n            /**\n             * Purpose 1 is never allowed to be true for legitimate interest\n             */\n            tcModel.purposeLegitimateInterests.unset(1);\n            /**\n             * If a Vendor does not declare a purpose for consent or legitimate\n             * interest they should not have a positive signal for it. This code\n             * removes positive signals created mistakingly.\n             */\n            const vectorToIntMap = new Map();\n            vectorToIntMap.set('legIntPurposes', tcModel.vendorLegitimateInterests);\n            vectorToIntMap.set('purposes', tcModel.vendorConsents);\n            vectorToIntMap.forEach((vector, gvlVendorKey) => {\n                vector.forEach((value, vendorId) => {\n                    if (value) {\n                        const vendor = gvl.vendors[vendorId];\n                        if (!vendor || vendor.deletedDate) {\n                            /**\n                             * If the vendor doesn't exist, then they should not receive a\n                             * positive signal\n                             */\n                            vector.unset(vendorId);\n                        }\n                        else if (vendor[gvlVendorKey].length === 0) {\n                            if (gvlVendorKey === 'legIntPurposes' && vendor['purposes'].length === 0 && vendor['legIntPurposes'].length === 0 && vendor['specialPurposes'].length > 0) {\n                                /**\n                                 * Per June 2021 Policy change, Vendors declaring only Special Purposes must\n                                 * have their legitimate interest Vendor bit set if they have been disclosed.\n                                 * This empty block ensures their LI bit remains set\n                                 */\n                            }\n                            else {\n                                /**\n                                 * If the vendor does exist, but they haven't declared any\n                                 * purposes for this legal basis, then we need to see if they can\n                                 * possibly have the legal basis from their flexible purposes.\n                                 */\n                                if (tcModel.isServiceSpecific) {\n                                    if (vendor.flexiblePurposes.length === 0) {\n                                        /**\n                                         * No flexible basis for any purposes, so we can safely remove\n                                         * this vendor from the legal basis.\n                                         */\n                                        vector.unset(vendorId);\n                                    }\n                                    else {\n                                        /**\n                                         * They have some flexible purposes, we should check for a\n                                         * publisher restriction value that would enable this vendor to\n                                         * have the override-preferred basis.\n                                         */\n                                        const restrictions = tcModel.publisherRestrictions.getRestrictions(vendorId);\n                                        let isValid = false;\n                                        for (let i = 0, len = restrictions.length; i < len && !isValid; i++) {\n                                            /**\n                                             * If this condition is true the loop will break.  If we are\n                                             * dealing with the consent purposes ('purposes') and the\n                                             * publisher restriction overrides to consent then it is\n                                             * valid for the vendor to have a positive signal for\n                                             * consent.  Likewise for legitimate interest purposes\n                                             * ('legIntPurposes') and requiring legitimate interest.\n                                             */\n                                            isValid = ((restrictions[i].restrictionType === RestrictionType.REQUIRE_CONSENT &&\n                                                gvlVendorKey === 'purposes') ||\n                                                (restrictions[i].restrictionType === RestrictionType.REQUIRE_LI &&\n                                                    gvlVendorKey === 'legIntPurposes'));\n                                        }\n                                        if (!isValid) {\n                                            /**\n                                             * if we came through the previous  loop without finding a\n                                             * valid reasing: no overriding restrictions (changes in\n                                             * legal basis) then it's not valid for this vendor to have\n                                             * this legal basis.\n                                             */\n                                            vector.unset(vendorId);\n                                        }\n                                    }\n                                }\n                                else {\n                                    /**\n                                     * This is a globally-scoped string so flexible purposes will not\n                                     * be able to change this value because purposeRestrictions only\n                                     * apply to service-specific strings.\n                                     */\n                                    vector.unset(vendorId);\n                                }\n                            }\n                        }\n                    }\n                });\n            });\n            tcModel.vendorsDisclosed.set(gvl.vendors);\n            return tcModel;\n        },\n    ];\n    static process(tcModel, options) {\n        const gvl = tcModel.gvl;\n        if (!gvl) {\n            throw new EncodingError('Unable to encode TCModel without a GVL');\n        }\n        if (!gvl.isReady) {\n            throw new EncodingError('Unable to encode TCModel tcModel.gvl.readyPromise is not resolved');\n        }\n        tcModel = tcModel.clone();\n        tcModel.consentLanguage = gvl.language.toUpperCase();\n        if (options?.version > 0 && options?.version <= this.processor.length) {\n            tcModel.version = options.version;\n        }\n        else {\n            /**\n             * this is equal to the latest or most current version\n             */\n            tcModel.version = this.processor.length;\n        }\n        const processorFunctionIndex = tcModel.version - 1;\n        if (!this.processor[processorFunctionIndex]) {\n            throw new EncodingError(`Invalid version: ${tcModel.version}`);\n        }\n        return this.processor[processorFunctionIndex](tcModel, gvl);\n    }\n}\n","export class Json {\n    static absCall(url, body, sendCookies, timeout) {\n        return new Promise((resolve, reject) => {\n            const req = new XMLHttpRequest();\n            const onLoad = () => {\n                // is the response done\n                if (req.readyState == XMLHttpRequest.DONE) {\n                    /**\n                     * For our purposes if it's not a 200 range response, then it's a\n                     * failure.\n                     */\n                    if (req.status >= 200 && req.status < 300) {\n                        let response = req.response;\n                        if (typeof response === 'string') {\n                            try {\n                                response = JSON.parse(response);\n                            }\n                            catch (e) { }\n                        }\n                        resolve(response);\n                    }\n                    else {\n                        reject(new Error(`HTTP Status: ${req.status} response type: ${req.responseType}`));\n                    }\n                }\n            };\n            const onError = () => {\n                reject(new Error('error'));\n            };\n            const onAbort = () => {\n                reject(new Error('aborted'));\n            };\n            const onTimeout = () => {\n                reject(new Error('Timeout ' + timeout + 'ms ' + url));\n            };\n            req.withCredentials = sendCookies;\n            req.addEventListener('load', onLoad);\n            req.addEventListener('error', onError);\n            req.addEventListener('abort', onAbort);\n            if (body === null) {\n                req.open('GET', url, true);\n            }\n            else {\n                req.open('POST', url, true);\n            }\n            req.responseType = 'json';\n            // IE has a problem if this is before the open\n            req.timeout = timeout;\n            req.ontimeout = onTimeout;\n            req.send(body);\n        });\n    }\n    /**\n     * @static\n     * @param {string} url - full path to POST to\n     * @param {object} body - JSON object to post\n     * @param {boolean} sendCookies - Whether or not to send the XMLHttpRequest with credentials or not\n     * @param {number} [timeout] - optional timeout in milliseconds\n     * @return {Promise<object>} - if the server responds the response will be returned here\n     */\n    static post(url, body, sendCookies = false, timeout = 0) {\n        return this.absCall(url, JSON.stringify(body), sendCookies, timeout);\n    }\n    /**\n     * @static\n     * @param {string} url - full path to the json\n     * @param {boolean} sendCookies - Whether or not to send the XMLHttpRequest with credentials or not\n     * @param {number} [timeout] - optional timeout in milliseconds\n     * @return {Promise<object>} - resolves with parsed JSON\n     */\n    static fetch(url, sendCookies = false, timeout = 0) {\n        return this.absCall(url, null, sendCookies, timeout);\n    }\n}\n","import { Cloneable } from './Cloneable.js';\nimport { GVLError } from './errors/index.js';\nimport { Json } from './Json.js';\nimport { ConsentLanguages } from './model/index.js';\n/**\n * class with utilities for managing the global vendor list.  Will use JSON to\n * fetch the vendor list from specified url and will serialize it into this\n * object and provide accessors.  Provides ways to group vendors on the list by\n * purpose and feature.\n */\nexport class GVL extends Cloneable {\n    static LANGUAGE_CACHE = new Map();\n    static CACHE = new Map();\n    static LATEST_CACHE_KEY = 0;\n    static DEFAULT_LANGUAGE = 'EN';\n    /**\n     * Set of available consent languages published by the IAB\n     */\n    static consentLanguages = new ConsentLanguages();\n    static baseUrl_;\n    /**\n     * baseUrl - Entities using the vendor-list.json are required by the iab to\n     * host their own copy of it to reduce the load on the iab's infrastructure\n     * so a 'base' url must be set to be put together with the versioning scheme\n     * of the filenames.\n     *\n     * @static\n     * @param {string} url - the base url to load the vendor-list.json from.  This is\n     * broken out from the filename because it follows a different scheme for\n     * latest file vs versioned files.\n     *\n     * @throws {GVLError} - If the url is http[s]://vendorlist.consensu.org/...\n     * this will throw an error.  IAB Europe requires that that CMPs and Vendors\n     * cache their own copies of the GVL to minimize load on their\n     * infrastructure.  For more information regarding caching of the\n     * vendor-list.json, please see [the TCF documentation on 'Caching the Global\n     * Vendor List'\n     * ](https://github.com/InteractiveAdvertisingBureau/GDPR-Transparency-and-Consent-Framework/blob/master/TCFv2/IAB%20Tech%20Lab%20-%20Consent%20string%20and%20vendor%20list%20formats%20v2.md#caching-the-global-vendor-list)\n     */\n    static set baseUrl(url) {\n        const notValid = /^https?:\\/\\/vendorlist\\.consensu\\.org\\//;\n        if (notValid.test(url)) {\n            throw new GVLError('Invalid baseUrl!  You may not pull directly from vendorlist.consensu.org and must provide your own cache');\n        }\n        // if a trailing slash was forgotten\n        if (url.length > 0 && url[url.length - 1] !== '/') {\n            url += '/';\n        }\n        this.baseUrl_ = url;\n    }\n    ;\n    /**\n     * baseUrl - Entities using the vendor-list.json are required by the iab to\n     * host their own copy of it to reduce the load on the iab's infrastructure\n     * so a 'base' url must be set to be put together with the versioning scheme\n     * of the filenames.\n     *\n     * @static\n     * @return {string} - returns the previously set baseUrl, the default is\n     * `undefined`\n     */\n    static get baseUrl() {\n        return this.baseUrl_;\n    }\n    /**\n     * @static\n     * @param {string} - the latest is assumed to be vendor-list.json because\n     * that is what the iab uses, but it could be different... if you want\n     */\n    static latestFilename = 'vendor-list.json';\n    /**\n     * @static\n     * @param {string} - the versioned name is assumed to be\n     * vendor-list-v[VERSION].json where [VERSION] will be replaced with the\n     * specified version.  But it could be different... if you want just make\n     * sure to include the [VERSION] macro if you have a numbering scheme, it's a\n     * simple string substitution.\n     *\n     * eg.\n     * ```javascript\n     * GVL.baseUrl = \"http://www.mydomain.com/iabcmp/\";\n     * GVL.versionedFilename = \"vendorlist?getVersion=[VERSION]\";\n     * ```\n     */\n    static versionedFilename = 'archives/vendor-list-v[VERSION].json';\n    /**\n     * @param {string} - Translations of the names and descriptions for Purposes,\n     * Special Purposes, Features, and Special Features to non-English languages\n     * are contained in a file where attributes containing English content\n     * (except vendor declaration information) are translated.  The iab publishes\n     * one following the scheme below where the LANG is the iso639-1 language\n     * code.  For a list of available translations\n     * [please go here](https://register.consensu.org/Translation).\n     *\n     * eg.\n     * ```javascript\n     * GVL.baseUrl = \"http://www.mydomain.com/iabcmp/\";\n     * GVL.languageFilename = \"purposes?getPurposes=[LANG]\";\n     * ```\n     */\n    static languageFilename = 'purposes-[LANG].json';\n    /**\n     * @param {Promise} resolved when this GVL object is populated with the data\n     * or rejected if there is an error.\n     */\n    readyPromise;\n    /**\n     * @param {number} gvlSpecificationVersion - schema version for the GVL that is used\n     */\n    gvlSpecificationVersion;\n    /**\n     * @param {number} incremented with each published file change\n     */\n    vendorListVersion;\n    /**\n     * @param {number} tcfPolicyVersion - The TCF MO will increment this value\n     * whenever a GVL change (such as adding a new Purpose or Feature or a change\n     * in Purpose wording) legally invalidates existing TC Strings and requires\n     * CMPs to re-establish transparency and consent from users. If the policy\n     * version number in the latest GVL is different from the value in your TC\n     * String, then you need to re-establish transparency and consent for that\n     * user. A version 1 format TC String is considered to have a version value\n     * of 1.\n     */\n    tcfPolicyVersion;\n    /**\n     * @param {string | Date} lastUpdated - the date in which the vendor list\n     * json file  was last updated.\n     */\n    lastUpdated;\n    /**\n     * @param {IntMap<Purpose>} a collection of [[Purpose]]s\n     */\n    purposes;\n    /**\n     * @param {IntMap<Purpose>} a collection of [[Purpose]]s\n     */\n    specialPurposes;\n    /**\n     * @param {IntMap<Feature>} a collection of [[Feature]]s\n     */\n    features;\n    /**\n     * @param {IntMap<Feature>} a collection of [[Feature]]s\n     */\n    specialFeatures;\n    /**\n     * @param {boolean} internal reference of when the GVL is ready to be used\n     */\n    isReady_ = false;\n    /**\n     * @param {IntMap<Vendor>} a collection of [[Vendor]]s\n     */\n    vendors_;\n    vendorIds;\n    /**\n     * @param {IntMap<Vendor>} a collection of [[Vendor]]. Used as a backup if a whitelist is sets\n     */\n    fullVendorList;\n    /**\n     * @param {ByPurposeVendorMap} vendors by purpose\n     */\n    byPurposeVendorMap;\n    /**\n     * @param {IDSetMap} vendors by special purpose\n     */\n    bySpecialPurposeVendorMap;\n    /**\n     * @param {IDSetMap} vendors by feature\n     */\n    byFeatureVendorMap;\n    /**\n     * @param {IDSetMap} vendors by special feature\n     */\n    bySpecialFeatureVendorMap;\n    /**\n     * @param {IntMap<Stack>} a collection of [[Stack]]s\n     */\n    stacks;\n    lang_;\n    isLatest = false;\n    /**\n     * @param {VersionOrVendorList} [versionOrVendorList] - can be either a\n     * [[VendorList]] object or a version number represented as a string or\n     * number to download.  If nothing is passed the latest version of the GVL\n     * will be loaded\n     */\n    constructor(versionOrVendorList) {\n        super();\n        /**\n         * should have been configured before and instance was created and will\n         * persist through the app\n         */\n        let url = GVL.baseUrl;\n        this.lang_ = GVL.DEFAULT_LANGUAGE;\n        if (this.isVendorList(versionOrVendorList)) {\n            this.populate(versionOrVendorList);\n            this.readyPromise = Promise.resolve();\n        }\n        else {\n            if (!url) {\n                throw new GVLError('must specify GVL.baseUrl before loading GVL json');\n            }\n            if (versionOrVendorList > 0) {\n                const version = versionOrVendorList;\n                if (GVL.CACHE.has(version)) {\n                    this.populate(GVL.CACHE.get(version));\n                    this.readyPromise = Promise.resolve();\n                }\n                else {\n                    // load version specified\n                    url += GVL.versionedFilename.replace('[VERSION]', String(version));\n                    this.readyPromise = this.fetchJson(url);\n                }\n            }\n            else {\n                /**\n                 * whatever it is (or isn't)... it doesn't matter we'll just get the\n                 * latest. In this case we may have cached the latest version at key 0.\n                 * If we have then we'll just use that instead of making a request.\n                 * Otherwise we'll have to load it (and then we'll cache it for next\n                 * time)\n                 */\n                if (GVL.CACHE.has(GVL.LATEST_CACHE_KEY)) {\n                    this.populate(GVL.CACHE.get(GVL.LATEST_CACHE_KEY));\n                    this.readyPromise = Promise.resolve();\n                }\n                else {\n                    this.isLatest = true;\n                    this.readyPromise = this.fetchJson(url + GVL.latestFilename);\n                }\n            }\n        }\n    }\n    /**\n     * emptyLanguageCache\n     *\n     * @param {string} [lang] - Optional ISO 639-1 langauge code to remove from\n     * the cache.  Should be one of the languages in GVL.consentLanguages set.\n     * If not then the whole cache will be deleted.\n     * @return {boolean} - true if anything was deleted from the cache\n     */\n    static emptyLanguageCache(lang) {\n        let retr = false;\n        if (lang === undefined && GVL.LANGUAGE_CACHE.size > 0) {\n            GVL.LANGUAGE_CACHE = new Map();\n            retr = true;\n        }\n        else if (typeof lang === 'string' && this.consentLanguages.has(lang.toUpperCase())) {\n            GVL.LANGUAGE_CACHE.delete(lang.toUpperCase());\n            retr = true;\n        }\n        return retr;\n    }\n    /**\n     * emptyCache\n     *\n     * @param {number} [vendorListVersion] - version of the vendor list to delete\n     * from the cache.  If none is specified then the whole cache is deleted.\n     * @return {boolean} - true if anything was deleted from the cache\n     */\n    static emptyCache(vendorListVersion) {\n        let retr = false;\n        if (Number.isInteger(vendorListVersion) && vendorListVersion >= 0) {\n            GVL.CACHE.delete(vendorListVersion);\n            retr = true;\n        }\n        else if (vendorListVersion === undefined) {\n            GVL.CACHE = new Map();\n            retr = true;\n        }\n        return retr;\n    }\n    cacheLanguage() {\n        if (!GVL.LANGUAGE_CACHE.has(this.lang_)) {\n            GVL.LANGUAGE_CACHE.set(this.lang_, {\n                purposes: this.purposes,\n                specialPurposes: this.specialPurposes,\n                features: this.features,\n                specialFeatures: this.specialFeatures,\n                stacks: this.stacks,\n            });\n        }\n    }\n    async fetchJson(url) {\n        try {\n            this.populate(await Json.fetch(url));\n        }\n        catch (err) {\n            throw new GVLError(err.message);\n        }\n    }\n    /**\n     * getJson - Method for getting the JSON that was downloaded to created this\n     * `GVL` object\n     *\n     * @return {VendorList} - The basic JSON structure without the extra\n     * functionality and methods of this class.\n     */\n    getJson() {\n        return JSON.parse(JSON.stringify({\n            gvlSpecificationVersion: this.gvlSpecificationVersion,\n            vendorListVersion: this.vendorListVersion,\n            tcfPolicyVersion: this.tcfPolicyVersion,\n            lastUpdated: this.lastUpdated,\n            purposes: this.purposes,\n            specialPurposes: this.specialPurposes,\n            features: this.features,\n            specialFeatures: this.specialFeatures,\n            stacks: this.stacks,\n            vendors: this.fullVendorList,\n        }));\n    }\n    /**\n     * changeLanguage - retrieves the purpose language translation and sets the\n     * internal language variable\n     *\n     * @param {string} lang - ISO 639-1 langauge code to change language to\n     * @return {Promise<void | GVLError>} - returns the `readyPromise` and\n     * resolves when this GVL is populated with the data from the language file.\n     */\n    async changeLanguage(lang) {\n        const langUpper = lang.toUpperCase();\n        if (GVL.consentLanguages.has(langUpper)) {\n            if (langUpper !== this.lang_) {\n                this.lang_ = langUpper;\n                if (GVL.LANGUAGE_CACHE.has(langUpper)) {\n                    const cached = GVL.LANGUAGE_CACHE.get(langUpper);\n                    for (const prop in cached) {\n                        if (cached.hasOwnProperty(prop)) {\n                            this[prop] = cached[prop];\n                        }\n                    }\n                }\n                else {\n                    // load Language specified\n                    const url = GVL.baseUrl + GVL.languageFilename.replace('[LANG]', lang);\n                    try {\n                        await this.fetchJson(url);\n                        this.cacheLanguage();\n                    }\n                    catch (err) {\n                        throw new GVLError('unable to load language: ' + err.message);\n                    }\n                }\n            }\n        }\n        else {\n            throw new GVLError(`unsupported language ${lang}`);\n        }\n    }\n    get language() {\n        return this.lang_;\n    }\n    isVendorList(gvlObject) {\n        return gvlObject !== undefined && gvlObject.vendors !== undefined;\n    }\n    populate(gvlObject) {\n        /**\n         * these are populated regardless of whether it's a Declarations file or\n         * a VendorList\n         */\n        this.purposes = gvlObject.purposes;\n        this.specialPurposes = gvlObject.specialPurposes;\n        this.features = gvlObject.features;\n        this.specialFeatures = gvlObject.specialFeatures;\n        this.stacks = gvlObject.stacks;\n        if (this.isVendorList(gvlObject)) {\n            this.gvlSpecificationVersion = gvlObject.gvlSpecificationVersion;\n            this.tcfPolicyVersion = gvlObject.tcfPolicyVersion;\n            this.vendorListVersion = gvlObject.vendorListVersion;\n            this.lastUpdated = gvlObject.lastUpdated;\n            if (typeof this.lastUpdated === 'string') {\n                this.lastUpdated = new Date(this.lastUpdated);\n            }\n            this.vendors_ = gvlObject.vendors;\n            this.fullVendorList = gvlObject.vendors;\n            this.mapVendors();\n            this.isReady_ = true;\n            if (this.isLatest) {\n                /**\n                 * If the \"LATEST\" was requested then this flag will be set to true.\n                 * In that case we'll cache the GVL at the special key\n                 */\n                GVL.CACHE.set(GVL.LATEST_CACHE_KEY, this.getJson());\n            }\n            /**\n             * Whether or not it's the \"LATEST\" we'll cache the gvl at the version it\n             * is declared to be (if it's not already). to avoid downloading it again\n             * in the future.\n             */\n            if (!GVL.CACHE.has(this.vendorListVersion)) {\n                GVL.CACHE.set(this.vendorListVersion, this.getJson());\n            }\n        }\n        this.cacheLanguage();\n    }\n    mapVendors(vendorIds) {\n        // create new instances of the maps\n        this.byPurposeVendorMap = {};\n        this.bySpecialPurposeVendorMap = {};\n        this.byFeatureVendorMap = {};\n        this.bySpecialFeatureVendorMap = {};\n        // initializes data structure for purpose map\n        Object.keys(this.purposes).forEach((purposeId) => {\n            this.byPurposeVendorMap[purposeId] = {\n                legInt: new Set(),\n                consent: new Set(),\n                flexible: new Set(),\n            };\n        });\n        // initializes data structure for special purpose map\n        Object.keys(this.specialPurposes).forEach((purposeId) => {\n            this.bySpecialPurposeVendorMap[purposeId] = new Set();\n        });\n        // initializes data structure for feature map\n        Object.keys(this.features).forEach((featureId) => {\n            this.byFeatureVendorMap[featureId] = new Set();\n        });\n        // initializes data structure for feature map\n        Object.keys(this.specialFeatures).forEach((featureId) => {\n            this.bySpecialFeatureVendorMap[featureId] = new Set();\n        });\n        if (!Array.isArray(vendorIds)) {\n            vendorIds = Object.keys(this.fullVendorList).map((vId) => +vId);\n        }\n        this.vendorIds = new Set(vendorIds);\n        // assigns vendor ids to their respective maps\n        this.vendors_ = vendorIds.reduce((vendors, vendorId) => {\n            const vendor = this.vendors_[String(vendorId)];\n            if (vendor && vendor.deletedDate === undefined) {\n                vendor.purposes.forEach((purposeId) => {\n                    const purpGroup = this.byPurposeVendorMap[String(purposeId)];\n                    purpGroup.consent.add(vendorId);\n                });\n                vendor.specialPurposes.forEach((purposeId) => {\n                    this.bySpecialPurposeVendorMap[String(purposeId)].add(vendorId);\n                });\n                vendor.legIntPurposes.forEach((purposeId) => {\n                    this.byPurposeVendorMap[String(purposeId)].legInt.add(vendorId);\n                });\n                // could not be there\n                if (vendor.flexiblePurposes) {\n                    vendor.flexiblePurposes.forEach((purposeId) => {\n                        this.byPurposeVendorMap[String(purposeId)].flexible.add(vendorId);\n                    });\n                }\n                vendor.features.forEach((featureId) => {\n                    this.byFeatureVendorMap[String(featureId)].add(vendorId);\n                });\n                vendor.specialFeatures.forEach((featureId) => {\n                    this.bySpecialFeatureVendorMap[String(featureId)].add(vendorId);\n                });\n                vendors[vendorId] = vendor;\n            }\n            return vendors;\n        }, {});\n    }\n    getFilteredVendors(purposeOrFeature, id, subType, special) {\n        const properPurposeOrFeature = purposeOrFeature.charAt(0).toUpperCase() + purposeOrFeature.slice(1);\n        let vendorSet;\n        const retr = {};\n        if (purposeOrFeature === 'purpose' && subType) {\n            vendorSet = this['by' + properPurposeOrFeature + 'VendorMap'][String(id)][subType];\n        }\n        else {\n            vendorSet = this['by' + (special ? 'Special' : '') + properPurposeOrFeature + 'VendorMap'][String(id)];\n        }\n        vendorSet.forEach((vendorId) => {\n            retr[String(vendorId)] = this.vendors[String(vendorId)];\n        });\n        return retr;\n    }\n    /**\n     * getVendorsWithConsentPurpose\n     *\n     * @param {number} purposeId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the consent purpose id\n     */\n    getVendorsWithConsentPurpose(purposeId) {\n        return this.getFilteredVendors('purpose', purposeId, 'consent');\n    }\n    /**\n     * getVendorsWithLegIntPurpose\n     *\n     * @param {number} purposeId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the legInt (Legitimate Interest) purpose id\n     */\n    getVendorsWithLegIntPurpose(purposeId) {\n        return this.getFilteredVendors('purpose', purposeId, 'legInt');\n    }\n    /**\n     * getVendorsWithFlexiblePurpose\n     *\n     * @param {number} purposeId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the flexible purpose id\n     */\n    getVendorsWithFlexiblePurpose(purposeId) {\n        return this.getFilteredVendors('purpose', purposeId, 'flexible');\n    }\n    /**\n     * getVendorsWithSpecialPurpose\n     *\n     * @param {number} specialPurposeId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the special purpose id\n     */\n    getVendorsWithSpecialPurpose(specialPurposeId) {\n        return this.getFilteredVendors('purpose', specialPurposeId, undefined, true);\n    }\n    /**\n     * getVendorsWithFeature\n     *\n     * @param {number} featureId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the feature id\n     */\n    getVendorsWithFeature(featureId) {\n        return this.getFilteredVendors('feature', featureId);\n    }\n    /**\n     * getVendorsWithSpecialFeature\n     *\n     * @param {number} specialFeatureId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the special feature id\n     */\n    getVendorsWithSpecialFeature(specialFeatureId) {\n        return this.getFilteredVendors('feature', specialFeatureId, undefined, true);\n    }\n    /**\n     * vendors\n     *\n     * @return {IntMap<Vendor>} - the list of vendors as it would on the JSON file\n     * except if `narrowVendorsTo` was called, it would be that narrowed list\n     */\n    get vendors() {\n        return this.vendors_;\n    }\n    /**\n     * narrowVendorsTo - narrows vendors represented in this GVL to the list of ids passed in\n     *\n     * @param {number[]} vendorIds - list of ids to narrow this GVL to\n     * @return {void}\n     */\n    narrowVendorsTo(vendorIds) {\n        this.mapVendors(vendorIds);\n    }\n    /**\n     * isReady - Whether or not this instance is ready to be used.  This will be\n     * immediately and synchronously true if a vendorlist object is passed into\n     * the constructor or once the JSON vendorllist is retrieved.\n     *\n     * @return {boolean} whether or not the instance is ready to be interacted\n     * with and all the data is populated\n     */\n    get isReady() {\n        return this.isReady_;\n    }\n    /**\n     * clone - overrides base `clone()` method since GVL is a special class that\n     * represents a JSON structure with some additional functionality.\n     *\n     * @return {GVL}\n     */\n    clone() {\n        const result = new GVL(this.getJson());\n        /*\n         * If the current language of the GVL is not the default language, we set the language of\n         * the clone to the current language since a new GVL is always created with the default\n         * language. */\n        if (this.lang_ !== GVL.DEFAULT_LANGUAGE) {\n            /*\n             * Since the GVL language was changed, this means that an asynchronous changeLanguage\n             * call was made prior to cloning the GVL.  The new language specified has been cached\n             * by the GVL and this changeLanguage call made as a part of cloning the GVL will be\n             * synchronous. The code will look for the language definitions in the cache instead\n             * of creating a http request. */\n            result.changeLanguage(this.lang_);\n        }\n        return result;\n    }\n    static isInstanceOf(questionableInstance) {\n        const isSo = typeof questionableInstance === 'object';\n        return (isSo && typeof questionableInstance.narrowVendorsTo === 'function');\n    }\n}\n","import { Cloneable } from './Cloneable.js';\nimport { TCModelError } from './errors/index.js';\nimport { GVL } from './GVL.js';\nimport { PurposeRestrictionVector, Vector } from './model/index.js';\nexport class TCModel extends Cloneable {\n    /**\n     * Set of available consent languages published by the IAB\n     */\n    static consentLanguages = GVL.consentLanguages;\n    isServiceSpecific_ = false;\n    supportOOB_ = true;\n    useNonStandardStacks_ = false;\n    purposeOneTreatment_ = false;\n    publisherCountryCode_ = 'AA';\n    version_ = 2;\n    consentScreen_ = 0;\n    policyVersion_ = 2;\n    consentLanguage_ = 'EN';\n    cmpId_ = 0;\n    cmpVersion_ = 0;\n    vendorListVersion_ = 0;\n    numCustomPurposes_ = 0;\n    // Member Variable for GVL\n    gvl_;\n    created;\n    lastUpdated;\n    /**\n     * The TCF designates certain Features as special, that is, a CMP must afford\n     * the user a means to opt in to their use. These Special Features are\n     * published and numbered in the GVL separately from normal Features.\n     * Provides for up to 12 special features.\n     */\n    specialFeatureOptins = new Vector();\n    /**\n     * Renamed from `PurposesAllowed` in TCF v1.1\n     * The userâ€™s consent value for each Purpose established on the legal basis\n     * of consent. Purposes are published in the Global Vendor List (see. [[GVL]]).\n     */\n    purposeConsents = new Vector();\n    /**\n     * The userâ€™s permission for each Purpose established on the legal basis of\n     * legitimate interest. If the user has exercised right-to-object for a\n     * purpose.\n     */\n    purposeLegitimateInterests = new Vector();\n    /**\n     * The userâ€™s consent value for each Purpose established on the legal basis\n     * of consent, for the publisher.  Purposes are published in the Global\n     * Vendor List.\n     */\n    publisherConsents = new Vector();\n    /**\n     * The userâ€™s permission for each Purpose established on the legal basis of\n     * legitimate interest.  If the user has exercised right-to-object for a\n     * purpose.\n     */\n    publisherLegitimateInterests = new Vector();\n    /**\n     * The userâ€™s consent value for each Purpose established on the legal basis\n     * of consent, for the publisher.  Purposes are published in the Global\n     * Vendor List.\n     */\n    publisherCustomConsents = new Vector();\n    /**\n     * The userâ€™s permission for each Purpose established on the legal basis of\n     * legitimate interest.  If the user has exercised right-to-object for a\n     * purpose that is established in the publisher's custom purposes.\n     */\n    publisherCustomLegitimateInterests = new Vector();\n    /**\n     * set by a publisher if they wish to collect consent and LI Transparency for\n     * purposes outside of the TCF\n     */\n    customPurposes;\n    /**\n     * Each [[Vendor]] is keyed by id. Their consent value is true if it is in\n     * the Vector\n     */\n    vendorConsents = new Vector();\n    /**\n     * Each [[Vendor]] is keyed by id. Whether their Legitimate Interests\n     * Disclosures have been established is stored as boolean.\n     * see: [[Vector]]\n     */\n    vendorLegitimateInterests = new Vector();\n    /**\n     * The value included for disclosed vendors signals which vendors have been\n     * disclosed to the user in the interface surfaced by the CMP. This section\n     * content is required when writing a TC string to the global (consensu)\n     * scope. When a CMP has read from and is updating a TC string from the\n     * global consensu.org storage, the CMP MUST retain the existing disclosure\n     * information and only add information for vendors that it has disclosed\n     * that had not been disclosed by other CMPs in prior interactions with this\n     * device/user agent.\n     */\n    vendorsDisclosed = new Vector();\n    /**\n     * Signals which vendors the publisher permits to use OOB legal bases.\n     */\n    vendorsAllowed = new Vector();\n    publisherRestrictions = new PurposeRestrictionVector();\n    /**\n     * Constructs the TCModel. Passing a [[GVL]] is optional when constructing\n     * as this TCModel may be constructed from decoding an existing encoded\n     * TCString.\n     *\n     * @param {GVL} [gvl]\n     */\n    constructor(gvl) {\n        super();\n        if (gvl) {\n            this.gvl = gvl;\n        }\n        this.updated();\n    }\n    /**\n     * sets the [[GVL]] with side effects of also setting the `vendorListVersion`, `policyVersion`, and `consentLanguage`\n     * @param {GVL} gvl\n     */\n    set gvl(gvl) {\n        /**\n         * set the reference, but make sure it's our GVL wrapper class.\n         */\n        if (!(GVL.isInstanceOf(gvl))) {\n            gvl = new GVL(gvl);\n        }\n        this.gvl_ = gvl;\n        this.publisherRestrictions.gvl = gvl;\n    }\n    /**\n     * @return {GVL} the gvl instance set on this TCModel instance\n     */\n    get gvl() {\n        return this.gvl_;\n    }\n    /**\n     * @param {number} integer - A unique ID will be assigned to each Consent\n     * Manager Provider (CMP) from the iab.\n     *\n     * @throws {TCModelError} if the value is not an integer greater than 1 as those are not valid.\n     */\n    set cmpId(integer) {\n        integer = Number(integer);\n        if (Number.isInteger(integer) && integer > 1) {\n            this.cmpId_ = integer;\n        }\n        else {\n            throw new TCModelError('cmpId', integer);\n        }\n    }\n    get cmpId() {\n        return this.cmpId_;\n    }\n    /**\n     * Each change to an operating CMP should receive a\n     * new version number, for logging proof of consent. CmpVersion defined by\n     * each CMP.\n     *\n     * @param {number} integer\n     *\n     * @throws {TCModelError} if the value is not an integer greater than 1 as those are not valid.\n     */\n    set cmpVersion(integer) {\n        integer = Number(integer);\n        if (Number.isInteger(integer) && integer > -1) {\n            this.cmpVersion_ = integer;\n        }\n        else {\n            throw new TCModelError('cmpVersion', integer);\n        }\n    }\n    get cmpVersion() {\n        return this.cmpVersion_;\n    }\n    /**\n     * The screen number is CMP and CmpVersion\n     * specific, and is for logging proof of consent.(For example, a CMP could\n     * keep records so that a publisher can request information about the context\n     * in which consent was gathered.)\n     *\n     * @param {number} integer\n     *\n     * @throws {TCModelError} if the value is not an integer greater than 0 as those are not valid.\n     */\n    set consentScreen(integer) {\n        integer = Number(integer);\n        if (Number.isInteger(integer) && integer > -1) {\n            this.consentScreen_ = integer;\n        }\n        else {\n            throw new TCModelError('consentScreen', integer);\n        }\n    }\n    get consentScreen() {\n        return this.consentScreen_;\n    }\n    /**\n     * @param {string} lang - [two-letter ISO 639-1 language\n     * code](http://www.loc.gov/standards/iso639-2/php/code_list.php) in which\n     * the CMP UI was presented\n     *\n     * @throws {TCModelError} if the value is not a length-2 string of alpha characters\n     */\n    set consentLanguage(lang) {\n        this.consentLanguage_ = lang;\n    }\n    get consentLanguage() {\n        return this.consentLanguage_;\n    }\n    /**\n     * @param {string} countryCode - [two-letter ISO 3166-1 alpha-2 country\n     * code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the publisher,\n     * determined by the CMP-settings of the publisher.\n     *\n     * @throws {TCModelError} if the value is not a length-2 string of alpha characters\n     */\n    set publisherCountryCode(countryCode) {\n        if (/^([A-z]){2}$/.test(countryCode)) {\n            this.publisherCountryCode_ = countryCode.toUpperCase();\n        }\n        else {\n            throw new TCModelError('publisherCountryCode', countryCode);\n        }\n    }\n    get publisherCountryCode() {\n        return this.publisherCountryCode_;\n    }\n    /**\n     * Version of the GVL used to create this TCModel. Global\n     * Vendor List versions will be released periodically.\n     *\n     * @param {number} integer\n     *\n     * @throws {TCModelError} if the value is not an integer greater than 0 as those are not valid.\n     */\n    set vendorListVersion(integer) {\n        /**\n         * first coerce to a number via leading '+' then take the integer value by\n         * bitshifting to the right.  This works on all types in JavaScript and if\n         * it's not valid then value will be 0.\n         */\n        integer = Number(integer) >> 0;\n        if (integer < 0) {\n            throw new TCModelError('vendorListVersion', integer);\n        }\n        else {\n            this.vendorListVersion_ = integer;\n        }\n    }\n    get vendorListVersion() {\n        if (this.gvl) {\n            return this.gvl.vendorListVersion;\n        }\n        else {\n            return this.vendorListVersion_;\n        }\n    }\n    /**\n     * From the corresponding field in the GVL that was\n     * used for obtaining consent. A new policy version invalidates existing\n     * strings and requires CMPs to re-establish transparency and consent from\n     * users.\n     *\n     * If a TCF policy version number is different from the one from the latest\n     * GVL, the CMP must re-establish transparency and consent.\n     *\n     * @param {number} num - You do not need to set this.  This comes\n     * directly from the [[GVL]].\n     *\n     */\n    set policyVersion(num) {\n        this.policyVersion_ = parseInt(num, 10);\n        if (this.policyVersion_ < 0) {\n            throw new TCModelError('policyVersion', num);\n        }\n    }\n    get policyVersion() {\n        if (this.gvl) {\n            return this.gvl.tcfPolicyVersion;\n        }\n        else {\n            return this.policyVersion_;\n        }\n    }\n    set version(num) {\n        this.version_ = parseInt(num, 10);\n    }\n    get version() {\n        return this.version_;\n    }\n    /**\n     * Whether the signals encoded in this TC String were from site-specific\n     * storage `true` versus â€˜globalâ€™ consensu.org shared storage `false`. A\n     * string intended to be stored in global/shared scope but the CMP is unable\n     * to store due to a user agent not accepting third-party cookies would be\n     * considered site-specific `true`.\n     *\n     * @param {boolean} bool - value to set. Some changes to other fields in this\n     * model will automatically change this value like adding publisher\n     * restrictions.\n     */\n    set isServiceSpecific(bool) {\n        this.isServiceSpecific_ = bool;\n    }\n    get isServiceSpecific() {\n        return this.isServiceSpecific_;\n    }\n    /**\n     * Non-standard stacks means that a CMP is using publisher-customized stack\n     * descriptions. Stacks (in terms of purposes in a stack) are pre-set by the\n     * IAB. As are titles. Descriptions are pre-set, but publishers can customize\n     * them. If they do, they need to set this bit to indicate that they've\n     * customized descriptions.\n     *\n     * @param {boolean} bool - value to set\n     */\n    set useNonStandardStacks(bool) {\n        this.useNonStandardStacks_ = bool;\n    }\n    get useNonStandardStacks() {\n        return this.useNonStandardStacks_;\n    }\n    /**\n     * Whether or not this publisher supports OOB signaling.  On Global TC String\n     * OOB Vendors Disclosed will be included if the publish wishes to no allow\n     * these vendors they should set this to false.\n     * @param {boolean} bool - value to set\n     */\n    set supportOOB(bool) {\n        this.supportOOB_ = bool;\n    }\n    get supportOOB() {\n        return this.supportOOB_;\n    }\n    /**\n     * `false` There is no special Purpose 1 status.\n     * Purpose 1 was disclosed normally (consent) as expected by Policy.  `true`\n     * Purpose 1 not disclosed at all. CMPs use PublisherCC to indicate the\n     * publisherâ€™s country of establishment to help Vendors determine whether the\n     * vendor requires Purpose 1 consent. In global scope TC strings, this field\n     * must always have a value of `false`. When a CMP encounters a global scope\n     * string with `purposeOneTreatment=true` then that string should be\n     * considered invalid and the CMP must re-establish transparency and consent.\n     *\n     * @param {boolean} bool\n     */\n    set purposeOneTreatment(bool) {\n        this.purposeOneTreatment_ = bool;\n    }\n    get purposeOneTreatment() {\n        return this.purposeOneTreatment_;\n    }\n    /**\n     * setAllVendorConsents - sets all vendors on the GVL Consent (true)\n     *\n     * @return {void}\n     */\n    setAllVendorConsents() {\n        this.vendorConsents.set(this.gvl.vendors);\n    }\n    /**\n     * unsetAllVendorConsents - unsets all vendors on the GVL Consent (false)\n     *\n     * @return {void}\n     */\n    unsetAllVendorConsents() {\n        this.vendorConsents.empty();\n    }\n    /**\n     * setAllVendorsDisclosed - sets all vendors on the GVL Vendors Disclosed (true)\n     *\n     * @return {void}\n     */\n    setAllVendorsDisclosed() {\n        this.vendorsDisclosed.set(this.gvl.vendors);\n    }\n    /**\n     * unsetAllVendorsDisclosed - unsets all vendors on the GVL Consent (false)\n     *\n     * @return {void}\n     */\n    unsetAllVendorsDisclosed() {\n        this.vendorsDisclosed.empty();\n    }\n    /**\n     * setAllVendorsAllowed - sets all vendors on the GVL Consent (true)\n     *\n     * @return {void}\n     */\n    setAllVendorsAllowed() {\n        this.vendorsAllowed.set(this.gvl.vendors);\n    }\n    /**\n     * unsetAllVendorsAllowed - unsets all vendors on the GVL Consent (false)\n     *\n     * @return {void}\n     */\n    unsetAllVendorsAllowed() {\n        this.vendorsAllowed.empty();\n    }\n    /**\n     * setAllVendorLegitimateInterests - sets all vendors on the GVL LegitimateInterests (true)\n     *\n     * @return {void}\n     */\n    setAllVendorLegitimateInterests() {\n        this.vendorLegitimateInterests.set(this.gvl.vendors);\n    }\n    /**\n     * unsetAllVendorLegitimateInterests - unsets all vendors on the GVL LegitimateInterests (false)\n     *\n     * @return {void}\n     */\n    unsetAllVendorLegitimateInterests() {\n        this.vendorLegitimateInterests.empty();\n    }\n    /**\n     * setAllPurposeConsents - sets all purposes on the GVL Consent (true)\n     *\n     * @return {void}\n     */\n    setAllPurposeConsents() {\n        this.purposeConsents.set(this.gvl.purposes);\n    }\n    /**\n     * unsetAllPurposeConsents - unsets all purposes on the GVL Consent (false)\n     *\n     * @return {void}\n     */\n    unsetAllPurposeConsents() {\n        this.purposeConsents.empty();\n    }\n    /**\n     * setAllPurposeLegitimateInterests - sets all purposes on the GVL LI Transparency (true)\n     *\n     * @return {void}\n     */\n    setAllPurposeLegitimateInterests() {\n        this.purposeLegitimateInterests.set(this.gvl.purposes);\n    }\n    /**\n     * unsetAllPurposeLegitimateInterests - unsets all purposes on the GVL LI Transparency (false)\n     *\n     * @return {void}\n     */\n    unsetAllPurposeLegitimateInterests() {\n        this.purposeLegitimateInterests.empty();\n    }\n    /**\n     * setAllSpecialFeatureOptins - sets all special featuresOptins on the GVL (true)\n     *\n     * @return {void}\n     */\n    setAllSpecialFeatureOptins() {\n        this.specialFeatureOptins.set(this.gvl.specialFeatures);\n    }\n    /**\n     * unsetAllSpecialFeatureOptins - unsets all special featuresOptins on the GVL (true)\n     *\n     * @return {void}\n     */\n    unsetAllSpecialFeatureOptins() {\n        this.specialFeatureOptins.empty();\n    }\n    setAll() {\n        this.setAllVendorConsents();\n        this.setAllPurposeLegitimateInterests();\n        this.setAllSpecialFeatureOptins();\n        this.setAllPurposeConsents();\n        this.setAllVendorLegitimateInterests();\n    }\n    unsetAll() {\n        this.unsetAllVendorConsents();\n        this.unsetAllPurposeLegitimateInterests();\n        this.unsetAllSpecialFeatureOptins();\n        this.unsetAllPurposeConsents();\n        this.unsetAllVendorLegitimateInterests();\n    }\n    get numCustomPurposes() {\n        let len = this.numCustomPurposes_;\n        if (typeof this.customPurposes === 'object') {\n            /**\n             * Keys are not guaranteed to be in order and likewise there is no\n             * requirement that the customPurposes be non-sparse.  So we have to sort\n             * and take the highest value.  Even if the set only contains 3 purposes\n             * but goes to ID 6 we need to set the number to 6 for the encoding to\n             * work properly since it's positional.\n             */\n            const purposeIds = Object.keys(this.customPurposes)\n                .sort((a, b) => Number(a) - Number(b));\n            len = parseInt(purposeIds.pop(), 10);\n        }\n        return len;\n    }\n    set numCustomPurposes(num) {\n        this.numCustomPurposes_ = parseInt(num, 10);\n        if (this.numCustomPurposes_ < 0) {\n            throw new TCModelError('numCustomPurposes', num);\n        }\n    }\n    /**\n     * updated - updates the created and lastUpdated dates with a 'now' day-level UTC timestamp\n     *\n     * @return {void}\n     */\n    updated() {\n        const date = new Date();\n        const utcDate = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));\n        this.created = utcDate;\n        this.lastUpdated = utcDate;\n    }\n}\n","import { Base64Url, BitLength, SegmentEncoder, SegmentSequence, SemanticPreEncoder, } from './encoder/index.js';\nimport { SegmentIDs } from './model/index.js';\nimport { IntEncoder } from './encoder/field/IntEncoder.js';\nimport { TCModel } from './TCModel.js';\n/**\n * Main class for encoding and decoding a\n * TCF Transparency and Consent String\n */\nexport class TCString {\n    /**\n     * encodes a model into a TCString\n     *\n     * @param {TCModel} tcModel - model to convert into encoded string\n     * @param {EncodingOptions} options - for encoding options other than default\n     * @return {string} - base64url encoded Transparency and Consent String\n     */\n    static encode(tcModel, options) {\n        let out = '';\n        let sequence;\n        tcModel = SemanticPreEncoder.process(tcModel, options);\n        /**\n           * If they pass in a special segment sequence.\n           */\n        if (Array.isArray(options?.segments)) {\n            sequence = options.segments;\n        }\n        else {\n            sequence = new SegmentSequence(tcModel, options)['' + tcModel.version];\n        }\n        sequence.forEach((segment, idx) => {\n            let dotMaybe = '';\n            if (idx < sequence.length - 1) {\n                dotMaybe = '.';\n            }\n            out += SegmentEncoder.encode(tcModel, segment) + dotMaybe;\n        });\n        return out;\n    }\n    /**\n     * Decodes a string into a TCModel\n     *\n     * @param {string} encodedTCString - base64url encoded Transparency and\n     * Consent String to decode - can also be a single or group of segments of\n     * the string\n     * @param {string} [tcModel] - model to enhance with the information.  If\n     * none is passed a new instance of TCModel will be created.\n     * @return {TCModel} - Returns populated TCModel\n     */\n    static decode(encodedTCString, tcModel) {\n        const segments = encodedTCString.split('.');\n        const len = segments.length;\n        if (!tcModel) {\n            tcModel = new TCModel();\n        }\n        for (let i = 0; i < len; i++) {\n            const segString = segments[i];\n            /**\n             * first char will contain 6 bits, we only need the first 3. In version 1\n             * and 2 of the TC string there is no segment type for the CORE string.\n             * Instead the first 6 bits are reserved for the encoding version, but\n             * because we're only on a maximum of encoding version 2 the first 3 bits\n             * in the core segment will evaluate to 0.\n             */\n            const firstChar = Base64Url.decode(segString.charAt(0));\n            const segTypeBits = firstChar.substr(0, BitLength.segmentType);\n            const segment = SegmentIDs.ID_TO_KEY[IntEncoder.decode(segTypeBits, BitLength.segmentType).toString()];\n            SegmentEncoder.decode(segString, tcModel, segment);\n        }\n        return tcModel;\n    }\n}\n","import { TCString } from '@iabtcf/core';\n\n/**\n * Dekodiert einen IAB TCF v2.0 Consent String und gibt das JSON-Objekt zurÃ¼ck.\n * @param {string} tcString - Der TC-String zum Dekodieren.\n * @returns {object} Dekodiertes Consent-Objekt (TCModel).\n */\nfunction decodeTCString(tcString) {\n  try {\n    const tcData = TCString.decode(tcString);\n    return tcData;\n  } catch (error) {\n    throw new Error(`Fehler beim Dekodieren des TC-Strings: ${error.message}`);\n  }\n}\n\n// Stelle die Funktion global zur VerfÃ¼gung\nwindow.decodeTCString = decodeTCString;\n"],"names":["DecodingError","Error","constructor","msg","super","this","name","EncodingError","GVLError","TCModelError","fieldName","passedValue","Base64Url","static","Map","encode","str","test","padding","length","LCM","repeat","result","i","BASIS","DICT","parseInt","substr","decode","strBits","REVERSE_DICT","get","toString","Cloneable","clone","myClone","Object","keys","forEach","key","value","deepClone","undefined","item","itsType","Date","getTime","Symbol","iterator","ar","subItem","push","Array","retr","prop","hasOwnProperty","BinarySearchTree","root","getRoot","isEmpty","add","node","left","right","current","pre","contains","min","max","remove","parent","parentSide","minVal","build","values","tree","rootIndex","rightTree","slice","leftTree","ConsentLanguages","Set","has","langSet","callback","size","Fields","RestrictionType","DeviceDisclosureStorageAccessType","Segment","VectorEncodingType","PurposeRestriction","purposeId_","restrictionType","purposeId","unHash","hash","splitUp","split","hashSeparator","purpRestriction","isValid","idNum","Number","isInteger","NOT_ALLOWED","REQUIRE_CONSENT","REQUIRE_LI","isSameAs","otherPR","PurposeRestrictionVector","bitLength","map","gvl_","isOkToHave","vendorId","gvl","vendors","vendor","legIntPurposes","includes","purposes","flexiblePurposes","purposeRestriction","set","restrictPurposeToLegalBasis","vendorIds","lastEntry","getVendors","vendorSet","bst","from","getRestrictionType","rType","getRestrictions","vendorHasRestriction","restrictions","getMaxVendorId","Math","getPurposes","purposeIds","delete","numRestrictions","SegmentIDs","CORE","VENDORS_DISCLOSED","VENDORS_ALLOWED","PUBLISHER_TC","Vector","maxId_","set_","maxId","id","unset","isArray","strId","isIntMap","every","itemResult","isValidNumber","isSet","empty","setAll","intMap","BitLength","cmpId","cmpVersion","consentLanguage","consentScreen","created","isServiceSpecific","lastUpdated","policyVersion","publisherCountryCode","publisherLegitimateInterests","publisherConsents","purposeConsents","purposeLegitimateInterests","purposeOneTreatment","specialFeatureOptins","useNonStandardStacks","vendorListVersion","version","BooleanEncoder","String","IntEncoder","numBits","bitString","DateEncoder","round","date","setTime","FixedVectorEncoder","vector","LangEncoder","firstLetter","toUpperCase","charCodeAt","secondLetter","ASCII_START","mid","fromCharCode","PurposeRestrictionVectorEncoder","prVector","len","numEntries","startId","rangeField","lastVendorId","gvlVendorIds","nextGvlVendor","isRange","encodedString","index","j","isARange","anyBoolean","startOrOnlyVendorId","endVendorId","k","VendorVectorEncoder","ranges","rangeIsSmaller","range","retrString","bitField","headerLength","encodingType","bitFieldLength","minRangeLength","singleOrRange","rangeLength","curValue","RANGE","buildRangeEncoding","FIELD","charAt","isIdRange","firstId","secondId","rangeString","single","FieldEncoderMap","vendorConsents","vendorLegitimateInterests","publisherRestrictions","segmentType","vendorsDisclosed","vendorsAllowed","numCustomPurposes","publisherCustomConsents","publisherCustomLegitimateInterests","FieldSequence","SegmentSequence","tcModel","options","isForVendors","supportOOB","SegmentEncoder","segment","sequence","fieldSequence","err","KEY_TO_ID","fieldEncoderMap","encoder","isPublisherCustom","message","bStringIdx","bits","indexOf","SemanticPreEncoder","vectorToIntMap","gvlVendorKey","deletedDate","process","isReady","language","processor","processorFunctionIndex","Json","absCall","url","body","sendCookies","timeout","Promise","resolve","reject","req","XMLHttpRequest","withCredentials","addEventListener","readyState","DONE","status","response","JSON","parse","e","responseType","open","ontimeout","send","post","stringify","fetch","GVL","baseUrl","baseUrl_","readyPromise","gvlSpecificationVersion","tcfPolicyVersion","specialPurposes","features","specialFeatures","isReady_","vendors_","fullVendorList","byPurposeVendorMap","bySpecialPurposeVendorMap","byFeatureVendorMap","bySpecialFeatureVendorMap","stacks","lang_","isLatest","versionOrVendorList","DEFAULT_LANGUAGE","isVendorList","populate","CACHE","versionedFilename","replace","fetchJson","LATEST_CACHE_KEY","latestFilename","emptyLanguageCache","lang","LANGUAGE_CACHE","consentLanguages","emptyCache","cacheLanguage","getJson","changeLanguage","langUpper","cached","languageFilename","gvlObject","mapVendors","legInt","consent","flexible","featureId","vId","reduce","getFilteredVendors","purposeOrFeature","subType","special","properPurposeOrFeature","getVendorsWithConsentPurpose","getVendorsWithLegIntPurpose","getVendorsWithFlexiblePurpose","getVendorsWithSpecialPurpose","specialPurposeId","getVendorsWithFeature","getVendorsWithSpecialFeature","specialFeatureId","narrowVendorsTo","isInstanceOf","questionableInstance","TCModel","isServiceSpecific_","supportOOB_","useNonStandardStacks_","purposeOneTreatment_","publisherCountryCode_","version_","consentScreen_","policyVersion_","consentLanguage_","cmpId_","cmpVersion_","vendorListVersion_","numCustomPurposes_","customPurposes","updated","integer","countryCode","num","bool","setAllVendorConsents","unsetAllVendorConsents","setAllVendorsDisclosed","unsetAllVendorsDisclosed","setAllVendorsAllowed","unsetAllVendorsAllowed","setAllVendorLegitimateInterests","unsetAllVendorLegitimateInterests","setAllPurposeConsents","unsetAllPurposeConsents","setAllPurposeLegitimateInterests","unsetAllPurposeLegitimateInterests","setAllSpecialFeatureOptins","unsetAllSpecialFeatureOptins","unsetAll","sort","a","b","pop","utcDate","UTC","getUTCFullYear","getUTCMonth","getUTCDate","TCString","out","segments","idx","dotMaybe","encodedTCString","segString","segTypeBits","ID_TO_KEY","window","decodeTCString","tcString","error"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]}